{source}
<?php
// this is the mylottoexpert entire code live 
defined('_JEXEC') or die;

// --------------------------------------------------
// Bootstrap: Get common Joomla objects (no "use" in Sorcerer)
// --------------------------------------------------
$app  = \Joomla\CMS\Factory::getApplication();
$user = \Joomla\CMS\Factory::getUser();
$db   = \Joomla\CMS\Factory::getDbo();

if ($user->guest) {
    $app->enqueueMessage('You must be logged in to view or save your predictions.', 'error');
    $app->redirect(\Joomla\CMS\Uri\Uri::base() . 'index.php?option=com_users&view=login');
    exit;
}
// --------------------------------------------------
// Helper Functions (must be in the first PHP block for Sorcerer)
// --------------------------------------------------
/**
 * User profile prefs (stored in #__user_profiles)
 */
function getUserPref($db, $userId, $key, $default = '1') {
    $query = $db->getQuery(true)
        ->select($db->quoteName('profile_value'))
        ->from($db->quoteName('#__user_profiles'))
        ->where($db->quoteName('user_id') . ' = ' . (int)$userId)
        ->where($db->quoteName('profile_key') . ' = ' . $db->quote('mylotto.' . $key))
        ->order($db->quoteName('ordering') . ' ASC')
        ->setLimit(1);
    $db->setQuery($query);
    $val = $db->loadResult();
    if ($val === null || $val === '') return $default;
    $decoded = json_decode($val, true);
    if (json_last_error() === JSON_ERROR_NONE) {
        return (string)($decoded ?? $default);
    }
    return (string)$val;
}

function setUserPref($db, $userId, $key, $value) {
    $value = (string)$value;
    $query = $db->getQuery(true)
        ->select('COUNT(*)')
        ->from($db->quoteName('#__user_profiles'))
        ->where($db->quoteName('user_id') . ' = ' . (int)$userId)
        ->where($db->quoteName('profile_key') . ' = ' . $db->quote('mylotto.' . $key));
    $db->setQuery($query);
    $exists = (int)$db->loadResult() > 0;

    if ($exists) {
        $query = $db->getQuery(true)
            ->update($db->quoteName('#__user_profiles'))
            ->set($db->quoteName('profile_value') . ' = ' . $db->quote(json_encode($value)))
            ->where($db->quoteName('user_id') . ' = ' . (int)$userId)
            ->where($db->quoteName('profile_key') . ' = ' . $db->quote('mylotto.' . $key));
    } else {
        $columns = ['user_id','profile_key','profile_value','ordering'];
        $values  = [
            (int)$userId,
            $db->quote('mylotto.' . $key),
            $db->quote(json_encode($value)),
            0
        ];
        $query = $db->getQuery(true)
            ->insert($db->quoteName('#__user_profiles'))
            ->columns(array_map([$db,'quoteName'], $columns))
            ->values(implode(',', $values));
    }
    $db->setQuery($query);
    $db->execute();
}

/**
 * Derive a concise label from a saved run row for the Best Settings Snapshot.
 * Shows method name and optional run mode / template name.
 */
function buildBestSettingsSummary(array $row, array $methodLabels)
{
    $src = isset($row['source']) ? (string)$row['source'] : '';

    $label = isset($methodLabels[$src])
        ? (string)$methodLabels[$src]
        : ucwords(str_replace('_', ' ', $src));

    $templateName = '';
    if (isset($row['template_name']) && $row['template_name'] !== null && $row['template_name'] !== '') {
        $templateName = (string)$row['template_name'];
    } elseif (isset($row['settings_template_name']) && $row['settings_template_name'] !== null && $row['settings_template_name'] !== '') {
        $templateName = (string)$row['settings_template_name'];
    }
    if ($templateName !== '') {
        return $label . ' - ' . $templateName;
    }

    if ($src === 'skai_prediction') {
        $mode = isset($row['skai_run_mode']) ? trim((string)$row['skai_run_mode']) : '';
        $modeLabel = $mode !== '' ? ucwords(str_replace('_', ' ', $mode)) : 'Default';
        return $label . ' - ' . $modeLabel;
    }

    return $label;
}

// ──────────────────────────────────────────────────────────────
// New Features toggle (persisted in #__user_profiles)
// Stored as '1' (show) / '0' (hide).
// We can safely call helpers before their textual definition (PHP parses file first).
$showNewFeatures = getUserPref($db, (int) $user->id, 'showNewFeatures', '1') === '1';

// Allow POST toggle via form
if ($app->input->getMethod() === 'POST' && $app->input->post->get('toggle_new_features', '', 'STRING') !== '') {
    if (!\Joomla\CMS\Session\Session::checkToken('post')) {
        die('Invalid Token');
    }
    $newVal = $app->input->post->get('new_features_enabled', '0', 'STRING') === '1' ? '1' : '0';
    setUserPref($db, (int) $user->id, 'showNewFeatures', $newVal);
    $showNewFeatures = ($newVal === '1');
}
// --------------------------------------------------
// Prediction List: Recency Sort Preference (persisted in #__user_profiles)
// --------------------------------------------------
$predSortPref = getUserPref($db, (int)$user->id, 'predSort', 'desc'); // 'desc' = newest→oldest (default)
$predSortDir  = (strtolower($predSortPref) === 'asc') ? 'ASC' : 'DESC';

// Allow POST change via form
if ($app->input->getMethod() === 'POST' && $app->input->post->get('change_sort_dir', '', 'STRING') !== '') {
    if (!\Joomla\CMS\Session\Session::checkToken('post')) {
        die('Invalid Token');
    }
    $dir = strtolower($app->input->post->get('pred_sort_dir', 'desc', 'STRING'));
    $dir = ($dir === 'asc') ? 'asc' : 'desc';
    setUserPref($db, (int)$user->id, 'predSort', $dir);
    $predSortDir = ($dir === 'asc') ? 'ASC' : 'DESC';
}

// --------------------------------------------------
// Handle Prediction Deletion / Template Actions
// IMPORTANT: Only enforce CSRF when THIS page’s actions are triggered.
// This avoids breaking unrelated module POSTs that may target this URL.
// --------------------------------------------------

if ($app->input->getMethod() === 'POST') {

    // Detect whether this POST is intended for mylottoexpert actions
    $hasDashboardAction =
        ($app->input->post->getInt('delete_set', 0) > 0) ||
        ($app->input->post->get('delete_all_predictions', '', 'STRING') !== '') ||
        ($app->input->post->get('delete_lottery_predictions', '', 'STRING') !== '') ||
        ($app->input->post->getInt('delete_setting_template', 0) > 0) ||
        ($app->input->post->get('save_setting_template', '', 'STRING') !== '') ||
        ($app->input->post->get('toggle_new_features', '', 'STRING') !== '') ||
        ($app->input->post->get('change_sort_dir', '', 'STRING') !== '');

    if ($hasDashboardAction && !\Joomla\CMS\Session\Session::checkToken('post')) {
        $app->enqueueMessage('Your session expired. Please refresh and try again.', 'error');
        $app->redirect(\Joomla\CMS\Uri\Uri::getInstance()->toString());
        exit;
    }

    // Delete single prediction (hardened: use Joomla input filtering)
    $id = $app->input->post->getInt('delete_set', 0);
    if ($id > 0) {

        $q = $db->getQuery(true)

            ->delete($db->quoteName('#__user_saved_numbers'))
            ->where($db->quoteName('id') . ' = ' . $id)
            ->where($db->quoteName('user_id') . ' = ' . (int) $user->id);

        $db->setQuery($q);
        try {
            $db->execute();
            $app->enqueueMessage('Prediction deleted.', 'message');
            $app->redirect(\Joomla\CMS\Uri\Uri::getInstance()->toString());
        } catch (Exception $e) {
            $app->enqueueMessage('Error deleting: ' . $e->getMessage(), 'error');
        }
    }

    // Delete all predictions (hardened: use Joomla input filtering)
    $doDeleteAll = $app->input->post->get('delete_all_predictions', '', 'STRING') !== '';
    if ($doDeleteAll) {
        $q = $db->getQuery(true)
            ->delete($db->quoteName('#__user_saved_numbers'))
            ->where($db->quoteName('user_id') . ' = ' . (int) $user->id);


        $db->setQuery($q);
        try {
            $db->execute();
            $app->enqueueMessage('All predictions deleted.', 'message');
            $app->redirect(\Joomla\CMS\Uri\Uri::getInstance()->toString());
        } catch (Exception $e) {
            $app->enqueueMessage('Error deleting all: ' . $e->getMessage(), 'error');
        }
    }

// Delete all predictions for a single lottery + draw date (group delete) — hardened input
$doGroupDelete = $app->input->post->get('delete_lottery_predictions', '', 'STRING') !== '';
$lotteryId     = $app->input->post->getInt('lottery_id', 0);
$drawDateRaw   = $app->input->post->getString('draw_date', '');
if ($doGroupDelete && $lotteryId && $drawDateRaw !== '') {
    $drawDate  = date('Y-m-d', strtotime($drawDateRaw)); // normalize

    $q = $db->getQuery(true)
        ->delete($db->quoteName('#__user_saved_numbers'))

        ->where($db->quoteName('user_id') . ' = ' . (int) $user->id)
        ->where($db->quoteName('lottery_id') . ' = ' . $lotteryId)
        // compare only date portion of next_draw_date
        ->where('DATE(' . $db->quoteName('next_draw_date') . ') = ' . $db->quote($drawDate));

    $db->setQuery($q);
    try {
        $db->execute();
        $app->enqueueMessage('Deleted all predictions for this draw.', 'message');
        $app->redirect(\Joomla\CMS\Uri\Uri::getInstance()->toString());
    } catch (Exception $e) {
        $app->enqueueMessage('Error deleting group: ' . $e->getMessage(), 'error');
    }
}

// Delete saved setting template (hardened: use Joomla input filtering)
$id = $app->input->post->getInt('delete_setting_template', 0);
if ($id > 0) {

        // $id already sanitized above
        $q = $db->getQuery(true)
            ->delete($db->quoteName('#__user_saved_settings'))

            ->where($db->quoteName('id') . ' = ' . $id)
            ->where($db->quoteName('user_id') . ' = ' . (int) $user->id);

        $db->setQuery($q);
        try {
            $db->execute();
            $app->enqueueMessage('Saved setting deleted.', 'message');
            $app->redirect(\Joomla\CMS\Uri\Uri::getInstance()->toString());
        } catch (Exception $e) {
            $app->enqueueMessage('Error deleting saved setting: ' . $e->getMessage(), 'error');
        }
    }

    // Save prediction settings as a named template (hardened: use Joomla input filtering)
    if ($app->input->post->get('save_setting_template', '', 'STRING') !== '') {
        $settingName = trim($app->input->post->getString('setting_name', ''));
        $source      = $app->input->post->getString('source', '');
        $lotteryId   = $app->input->post->getInt('lottery_id', 0);
        $params      = [];

        // Define expected params based on source
        $keys = match ($source) {
            'ai_prediction'   => [
                'epochs', 'batch_size', 'dropout_rate',
                'learning_rate', 'activation_function',
                'hidden_layers', 'recency_decay',
            ],
            'skai_prediction' => [
                // Core neural hyperparameters
                'epochs', 'batch_size', 'dropout_rate',
                'learning_rate', 'activation_function',
                'hidden_layers', 'recency_decay',
                // Windows
                'skai_window_size', 'skip_window', 'draws_used', 'tuned_window',
                // Behavior & sampling
                'sampling_temperature', 'diversity_penalty', 'gap_scale',
                // Mode / automation
                'skai_run_mode', 'auto_tune', 'tune_used', 'best_window',
                // Output size
                'skai_top_n_numbers', 'skai_top_n_combos',
            ],
            'mcmc_prediction' => ['walks', 'burn_in', 'laplace_k', 'decay', 'chain_len'],
            'skip_hit'        => ['draws_analyzed', 'freq_weight', 'skip_weight', 'hist_weight'],
            default           => []
        };

        foreach ($keys as $k) {
            $val = $app->input->post->get($k, null, 'STRING'); // keep as STRING to avoid behavior changes
            if ($val !== null && $val !== '') {
                $params[$k] = $val;
            }
        }


        if ($settingName && $source && $lotteryId && $params) {
            $q = $db->getQuery(true)
                ->insert($db->quoteName('#__user_saved_settings'))
                ->columns(['user_id', 'lottery_id', 'source', 'setting_name', 'params'])
                ->values(implode(',', [
                    (int) $user->id,
                    $lotteryId,
                    $db->quote($source),
                    $db->quote($settingName),
                    $db->quote(json_encode($params))
                ]));

            $db->setQuery($q);
            try {
                $db->execute();
                $app->enqueueMessage('Settings saved.', 'message');
            } catch (Exception $e) {
                $app->enqueueMessage('Failed to save: ' . $e->getMessage(), 'error');
            }
        }
    }
}

// --------------------------------------------------
// Echo your Sorcerer module
// --------------------------------------------------
echo '{loadmoduleid 126}';
?>

[[div class="skai-section skai-section--tight skai-first-section"]]


[[div class="skai-section skai-section--tight"]]
  [[div class="skai-section__inner skai-stack skai-stack--loose"]]

    [[div class="skai-stack skai-stack--tight"]]
      [[div class="skai-section__eyebrow"]]
        Analysis Hub
      [[/div]]

      [[h2 class="skai-section__heading"]]
        What Matters Today
      [[/h2]]

      [[p class="skai-section__subtitle"]]
        Compare predictions, spot agreement signals, and decide your next play with confidence.
      [[/p]]
    [[/div]]

    [[div class="skai-inline skai-inline--tight" style="justify-content:space-between; align-items:center; margin-top:0.75rem;"]]

      [[div]]
        [[span class="skai-card__meta"]]
          <?php echo 'Welcome back, ' . htmlspecialchars($user->name, ENT_QUOTES) . '.'; ?>
        [[/span]]
      [[/div]]

      [[div class="skai-inline skai-inline--tight" style="justify-content:flex-end;"]]
        [[span class="skai-tag skai-tag--neutral skai-tag--xs"]]
          Member Dashboard
        [[/span]]
        [[a href="/why-lottoexpert-is-different"
            class="skai-link-muted"
            target="_blank"
            rel="noopener noreferrer"]]
          Why serious players choose data-driven lottery analysis
        [[/a]]
      [[/div]]

    [[/div]]

  [[/div]]
[[/div]]

[[style]]
/* Compact variant – mapped to SKAI card */
.info-card.compact { padding: 0.75rem; }

/* Tighten top-of-page so Module 126 sits flush at top */
.skai-first-section {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* Hide Joomla article title for this dashboard only */
.skai-page-scope ~ .page-header,
.skai-page-scope ~ .page-header h1,
.skai-page-scope ~ h1.page-header,
.skai-page-scope ~ .sp-page-title,
.skai-page-scope ~ .sp-page-title h1,
.skai-page-scope ~ .article-header,
.skai-page-scope ~ .article-header h1 {
  display: none !important;
  margin: 0 !important;
  padding: 0 !important;
}

/* If Helix adds top padding above component, tighten it */
.skai-page-scope {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

  .info-card.compact .skai-card__header { padding-bottom: 0.5rem; }
  .info-card.compact .skai-card__body { font-size: 0.9rem; line-height:1.3; }
  .info-card.compact ul { margin:0; padding-left:1.2rem; }
  .info-card.compact li { margin-bottom:0.4rem; }
  @media(min-width:640px) {
    .info-card.compact .columns { display:flex; gap:2rem; }
    .info-card.compact .column { flex:1; }
  }
  
  
[[/style]]

[[div id="info-card" class="skai-card info-card compact open"]]
  [[div class="skai-card__header"]]
    [[h3 class="skai-card__title"]]How This Works[[/h3]]
    [[button id="info-toggle" type="button" aria-label="Hide info"]]&times;[[/button]]  <!-- hardened: type="button" -->
  [[/div]]
  [[div class="skai-card__body skai-stack skai-stack--tight"]]

    [[p]]
      This hub shows your saved predictions from multiple analytical methods. When numbers appear across different methods, that's an [[strong]]agreement signal[[/strong]] — it means the methods independently arrived at similar conclusions. These signals help you decide, but they're probabilities, not promises.
    [[/p]]

    [[p style="margin-top:0.75rem; font-weight:600; color:#333;"]]
      What to look for:
    [[/p]]

    [[ul style="margin-top:0.25rem; margin-bottom:1rem; line-height:1.6;"]]
      [[li]][[strong]]Numbers that repeat[[/strong]] across 2+ methods — these are worth attention[[/li]]
      [[li]][[strong]]Where methods diverge[[/strong]] — different approaches see different patterns[[/li]]
      [[li]][[strong]]Your saved templates[[/strong]] — reuse tested settings for new draws[[/li]]
    [[/ul]]

    [[p style="font-size:0.85em; color:#555; margin-top:1rem; line-height:1.5;"]]
      Each method uses different math: pattern recognition, neural networks, probability sampling. When they agree, the signal is stronger. When they don't, you see the range of possibilities.
    [[/p]]

  [[/div]]
[[/div]]


<?php // New AI Features promo card removed intentionally – no UI rendered here. ?>


[[style]]
/* When info-card is not "open", hide its SKAI card body */
#info-card:not(.open) .skai-card__body { display: none; }

#info-toggle {
  background: none;
  border: none;
  font-size: 1.25rem;
  cursor: pointer;
}

/* Optional: compact switch appearance */
.skai-card__header form label input[type="checkbox"] {
  transform: scale(1.05);
}
[[/style]]

[[script]]
document.addEventListener('DOMContentLoaded', () => {
  // Render Sorcerer-style [[...]] markup to real HTML tags client-side.
  function S(str) {
    return String(str).replace(/\[\[/g, '<').replace(/\]\]/g, '>');
  }

  const card = document.getElementById('info-card');
  const btn  = document.getElementById('info-toggle');
  if (!card || !btn) return; // defensive: missing DOM nodes

  const key = 'myLottoExpertInfoOpen';

  // read persisted state safely (handles private mode / exceptions)
  let stored = null;
  try { stored = localStorage.getItem(key); } catch (e) { stored = null; }

  // default = whatever markup set (card has .open initially)
  const isOpen = (stored === null) ? card.classList.contains('open') : (stored !== 'false');

  if (!isOpen) {
    card.classList.remove('open');
    btn.setAttribute('aria-label', 'Show info');
  } else {
    btn.setAttribute('aria-label', 'Hide info');
  }

  btn.addEventListener('click', () => {
    const open = card.classList.toggle('open');
    try { localStorage.setItem(key, open ? 'true' : 'false'); } catch (e) {}
    btn.setAttribute('aria-label', open ? 'Hide info' : 'Show info');
  });
});
[[/script]]

<?php

// --------------------------------------------------
// Configuration Labels for prediction sources
// --------------------------------------------------
$sourceLabels = [
    'ai_prediction'    => 'Neural Network',
    'skip_hit'         => 'Pattern Analysis',
    'frequency'        => 'Frequency Map',
    'mcmc_prediction'  => 'Probability Sampling',
    'heatmap'          => 'Frequency Map',
    'skai_prediction'  => 'Hybrid Model',
];
$__methodLabels = $sourceLabels;

// Map source keys → short codes for compact display
$iconMap = [
    'ai_prediction'   => 'NN',
    'skip_hit'        => 'PA',
    'frequency'       => 'FM',
    'mcmc_prediction' => 'PS',
    'heatmap'         => 'FM',
    'skai_prediction' => 'HM',
];

/**
 * getLatestDrawing: Given a game ID, load the very latest draw record from that game's database table.
 *
 * @param   mixed           $gameId  Lottery game ID
 * @param   JDatabaseDriver $db      Joomla database object
 * @return  array|null              Associative array of the latest draw row, or null if not found
 */
function getLatestDrawing($gameId, $db)
{
    $configFile = JPATH_ROOT . '/lottery_skip_config.json';
    if (!file_exists($configFile)) {
        return null;
    }

    $json = json_decode(file_get_contents($configFile), true);
    if (json_last_error() !== JSON_ERROR_NONE || empty($json['lotteries'][$gameId])) {
        return null;
    }

    // Use "dbCol" as the table name
    $lotterySpec = $json['lotteries'][$gameId];
    $tbl         = $lotterySpec['dbCol'] ?? '';
    if (empty($tbl)) {
        return null;
    }

    $q = $db->getQuery(true)
        ->select('*')
        ->from($db->quoteName($db->replacePrefix($tbl)))
        ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
        ->order($db->quoteName('draw_date') . ' DESC')
        ->setLimit(1);

    $db->setQuery($q);
    return $db->loadAssoc();
}

/**
 * getDrawByDate: Given a game ID and a specific draw date, retrieve that exact draw row.
 *
 * @param   mixed               $gameId  Lottery game ID
 * @param   string              $date    Draw date (any strtotime-parsable string)
 * @param   JDatabaseDriver     $db      Joomla database object
 * @return  array<string,mixed>|null      Associative array of the draw row, or null if not found
 */
function getDrawByDate($gameId, $date, $db)
{
    $configFile = JPATH_ROOT . '/lottery_skip_config.json';
    if (!is_file($configFile)) {
        return null;
    }

    $json = json_decode(file_get_contents($configFile), true);
    if (json_last_error() !== JSON_ERROR_NONE
        || empty($json['lotteries'][$gameId]['dbCol'])
    ) {
        return null;
    }

    // Resolve table name from config
    $tbl = $json['lotteries'][$gameId]['dbCol'];
    if (!$tbl) {
        return null;
    }

    // Normalize incoming $date to YYYY-MM-DD; bail if invalid to avoid 1970-01-01
    $ts = strtotime((string) $date);
    if ($ts === false) {
        return null;
    }
    $dateOnly = date('Y-m-d', $ts);


    // Build and execute query
    $query = $db->getQuery(true)
        ->select('*')
        ->from($db->quoteName($db->replacePrefix($tbl)))
        ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
        // Compare only the date portion of draw_date
        ->where('DATE(' . $db->quoteName('draw_date') . ') = ' . $db->quote($dateOnly))
        ->setLimit(1);

    $db->setQuery($query);
    return $db->loadAssoc();
}

/**
 * getDrawFields: For a given gameId, read 'lottery_skip_config.json' to find which columns in the draw table
 * represent 'main_ball_columns' and 'extra_ball_column'.
 *
 * @param   mixed $gameId  Lottery game ID
 * @return  array          ['main' => array of column names, 'extra' => column name or null]
 */
function getDrawFields($gameId)
{
    $configFile = JPATH_ROOT . '/lottery_skip_config.json';
    if (!file_exists($configFile)) {
        return [];
    }

    $json = json_decode(file_get_contents($configFile), true);
    if (json_last_error() !== JSON_ERROR_NONE || empty($json['lotteries'][$gameId]['lotteryConfig'])) {
        return [];
    }

    $config     = $json['lotteries'][$gameId]['lotteryConfig'];
    $mainCols   = $config['main_ball_columns']  ?? [];
    $extraCol   = $config['extra_ball_column']  ?? null;

    return [
        'main'  => $mainCols,
        'extra' => $extraCol
    ];
}

/**
 * Map a US state/territory name → USPS abbreviation (uppercase).
 * Falls back to first two letters if unknown. Input may be mixed case.
 */
function stateToAbbrev(string $stateName): string
{
    static $map = [
        'alabama'=>'AL','alaska'=>'AK','arizona'=>'AZ','arkansas'=>'AR','california'=>'CA','colorado'=>'CO','connecticut'=>'CT','delaware'=>'DE',
        'district of columbia'=>'DC','washington dc'=>'DC','dc'=>'DC',
        'florida'=>'FL','georgia'=>'GA','hawaii'=>'HI','idaho'=>'ID','illinois'=>'IL','indiana'=>'IN','iowa'=>'IA','kansas'=>'KS','kentucky'=>'KY','louisiana'=>'LA',
        'maine'=>'ME','maryland'=>'MD','massachusetts'=>'MA','michigan'=>'MI','minnesota'=>'MN','mississippi'=>'MS','missouri'=>'MO','montana'=>'MT',
        'nebraska'=>'NE','nevada'=>'NV','new hampshire'=>'NH','new jersey'=>'NJ','new mexico'=>'NM','new york'=>'NY','north carolina'=>'NC','north dakota'=>'ND',
        'ohio'=>'OH','oklahoma'=>'OK','oregon'=>'OR','pennsylvania'=>'PA','rhode island'=>'RI','south carolina'=>'SC','south dakota'=>'SD',
        'tennessee'=>'TN','texas'=>'TX','utah'=>'UT','vermont'=>'VT','virginia'=>'VA','washington'=>'WA','west virginia'=>'WV','wisconsin'=>'WI','wyoming'=>'WY',
        // common territories some datasets include
        'puerto rico'=>'PR','guam'=>'GU','american samoa'=>'AS','northern mariana islands'=>'MP','us virgin islands'=>'VI'
    ];
    $k = strtolower(trim($stateName));
    if (isset($map[$k])) return $map[$k];
    // If input is already an abbreviation like “NY”
    if (strlen($stateName) === 2 && ctype_alpha($stateName)) return strtoupper($stateName);
    $two = strtoupper(preg_replace('/[^A-Za-z]/','', $stateName));
    return substr($two, 0, 2) ?: 'US';
}

/**
 * Build a safe logo path using your format:
 * /images/lottodb/us/{ST}/{game-name-slug}.png
 * Returns ['path' => string, 'exists' => bool, 'alt' => string]
 */
function buildLotteryLogoPath(string $stateName, string $gameName): array
{
    $abbrUpper = stateToAbbrev($stateName);       // e.g., AZ
    $abbrLower = strtolower($abbrUpper);          // e.g., az

    // Your exact spec: str_replace(' ','-', strtolower($gName))
    $slugExact = str_replace(' ', '-', strtolower($gameName));

    // A safer fallback slug (strip punctuation, compress dashes)
    $slugSafe  = strtolower(trim(preg_replace('/\s+/', '-', preg_replace('/[^A-Za-z0-9 ]/', '', $gameName))));
    $slugSafe  = preg_replace('/-+/', '-', $slugSafe);

    // Try candidates in this order (fast-fail):
    $candidates = [
        '/images/lottodb/us/' . $abbrLower . '/' . $slugExact . '.png',
        '/images/lottodb/us/' . $abbrUpper . '/' . $slugExact . '.png',
        '/images/lottodb/us/' . $abbrLower . '/' . $slugSafe  . '.png',
        '/images/lottodb/us/' . $abbrUpper . '/' . $slugSafe  . '.png',
    ];

    foreach ($candidates as $rel) {
        if (is_file(JPATH_ROOT . $rel)) {
            return ['path' => $rel, 'exists' => true, 'alt' => $gameName . ' logo'];
        }
    }

    // None found → return the first (your canonical) for <img src> if you prefer,
    // but we’ll mark exists=false so the badge shows instead.
    return ['path' => $candidates[0], 'exists' => false, 'alt' => $gameName . ' logo'];
}

/**
 * scoreRunFromDrawMap: Score a prediction run against a preloaded draw map entry.
 * Uses $drawMap (built via UNION ALL query) as the single data source -- no extra DB queries.
 *
 * @param array  $drawMap    Preloaded draw map keyed by "game_id|Y-m-d"
 * @param int    $gameId     Lottery game ID
 * @param string $drawDate   Draw date (any strtotime-parsable string)
 * @param array  $predMain   Predicted main numbers (ints; zeros are ignored)
 * @param int    $predExtra  Predicted extra ball (0 = not set)
 * @return array { has_draw, drawMain, drawExtra, hits_main, hits_extra }
 */
function scoreRunFromDrawMap($drawMap, $gameId, $drawDate, array $predMain, $predExtra = 0)
{
    $empty = array('has_draw' => false, 'drawMain' => array(), 'drawExtra' => array(), 'hits_main' => 0, 'hits_extra' => 0);
    $ts = strtotime((string)$drawDate);
    if ($ts === false) {
        return $empty;
    }
    $normDate = date('Y-m-d', $ts);
    $mapKey   = (int)$gameId . '|' . $normDate;
    if (!isset($drawMap[$mapKey])) {
        return $empty;
    }
    $row = $drawMap[$mapKey];

    // Extract main numbers from normalized columns (main_0, main_1, ...)
    $drawMain = array();
    for ($i = 0; $i < 25; $i++) {
        $k = 'main_' . $i;
        if (isset($row[$k]) && $row[$k] !== '' && $row[$k] !== null) {
            $v = (int)$row[$k];
            if ($v) {
                $drawMain[] = $v;
            }
        }
    }
    if (empty($drawMain)) {
        return $empty;
    }

    // Extract extra ball from normalized column
    $drawExtra = array();
    if (isset($row['extra_ball']) && $row['extra_ball'] !== '' && $row['extra_ball'] !== null) {
        $v = (int)$row['extra_ball'];
        if ($v) {
            $drawExtra[] = $v;
        }
    }

    // Count main-ball hits
    $hitsMain = 0;
    foreach ($predMain as $n) {
        if ($n !== 0 && in_array($n, $drawMain, true)) {
            $hitsMain++;
        }
    }
    // Count extra-ball hit
    $hitsExtra = 0;
    $predExtra = (int)$predExtra;
    if ($predExtra > 0 && !empty($drawExtra) && in_array($predExtra, $drawExtra, true)) {
        $hitsExtra = 1;
    }

    return array(
        'has_draw'   => true,
        'drawMain'   => $drawMain,
        'drawExtra'  => $drawExtra,
        'hits_main'  => $hitsMain,
        'hits_extra' => $hitsExtra,
    );
}

// --------------------------------------------------
// Load Data: Favorite Lotteries, Wheeling Systems, and Saved Predictions $part FROM {$tbl}
// --------------------------------------------------

// --------------------
// 1) Favorite Lotteries
// --------------------
$q = $db->getQuery(true)
    ->select([
        'l.lottery_id',
        'l.name AS lottery_name',
        's.name AS state_name',
        'c.name AS country_name',
        'l.lottery_urls',
        'l.game_id',
    ])
    ->from($db->quoteName('#__user_lottery_preferences', 'ulp'))
    ->join('INNER', $db->quoteName('#__lotteries', 'l') . ' ON ulp.lottery_id = l.lottery_id')
    ->join('LEFT',  $db->quoteName('#__states', 's') . ' ON l.state_id = s.state_id')
    ->join('LEFT',  $db->quoteName('#__countries', 'c') . ' ON s.country_id = c.country_id')
    ->where('ulp.user_id = ' . (int)$user->id)
    ->order('s.name, l.name');

$db->setQuery($q);
$favoriteLotteries = $db->loadAssocList() ?: [];

// Build lookup: lottery_id → country + state
$lottoMetaById = [];
foreach ($favoriteLotteries as $lotto) {
    $id = $lotto['lottery_id'];
    $state = $lotto['state_name'] ?? '';
    $country = $lotto['country_name'] ?? '';
    $lottoMetaById[$id] = [
        'state'   => $state,
        'country' => $country
    ];
}

// Build lookup: lottery_id → state_name
$lottoStatesById = [];
foreach ($favoriteLotteries as $lotto) {
    if (!empty($lotto['lottery_id']) && !empty($lotto['state_name'])) {
        $lottoStatesById[$lotto['lottery_id']] = $lotto['state_name'];
    }
}

// Build map of lottery_id → official URL
$lottoUrlsById = [];
foreach ($favoriteLotteries as $lotto) {
  if (!empty($lotto['lottery_id']) && !empty($lotto['lottery_urls'])) {
    $lottoUrlsById[$lotto['lottery_id']] = $lotto['lottery_urls'];
  }
}

// --------------------
// 2) Wheeling Systems & User's Favorites
// --------------------
$q = $db->getQuery(true)
    ->select('system_id, name, description, pick_size, number_range, assurance, games, url')
    ->from($db->quoteName('#__wheeling_systems'))
    ->order('pick_size, number_range, assurance');
$db->setQuery($q);
$wheelingSystems = $db->loadAssocList() ?: [];

$q = $db->getQuery(true)
    ->select('system_id')
    ->from($db->quoteName('#__user_wheeling_preferences'))
    ->where('user_id = ' . (int)$user->id);
$db->setQuery($q);
$favIds = array_column($db->loadAssocList(), 'system_id');

$favWheelingSystems = array_filter(
    $wheelingSystems,
    fn($s) => in_array($s['system_id'], $favIds, true)
);

// 1) Fetch saved predictions with timestamps
$q = $db->getQuery(true);
$q->select(array(
    'sn.id','sn.lottery_id','sn.next_draw_date','sn.source','sn.label','sn.main_numbers',
    'sn.extra_ball_numbers','sn.date_saved','sn.generated_at',

    'sn.epochs','sn.batch_size','sn.dropout_rate','sn.learning_rate',
    'sn.activation_function','sn.hidden_layers',
    'sn.recency_decay',
    'sn.walks','sn.burn_in','sn.laplace_k','sn.decay','sn.chain_len',
    'sn.draws_analyzed','sn.freq_weight','sn.skip_weight','sn.hist_weight',
    'sn.draws_used','sn.skip_window',
    'sn.auto_tune','sn.tune_used','sn.best_window',
    'sn.skai_blend_skip_pct','sn.skai_blend_ai_pct',
    'sn.sampling_temperature','sn.diversity_penalty','sn.gap_scale',
    'sn.skai_window_size','sn.skai_run_mode',
    'sn.skai_top_n_numbers','sn.skai_top_n_combos',
    'sn.digit_probabilities',
    'l.game_id','l.name AS lottery_name',
    'sn.pure_mode'


));
$q->from($db->quoteName('#__user_saved_numbers', 'sn'));
$q->join('LEFT', $db->quoteName('#__lotteries', 'l') . ' ON sn.lottery_id = l.lottery_id');

$q->where('sn.user_id = ' . (int) $user->id);
$q->order('sn.next_draw_date ' . $predSortDir . ', sn.source ASC, COALESCE(sn.generated_at,sn.date_saved) ' . $predSortDir);


$db->setQuery($q);
$savedSets = $db->loadObjectList() ?: [];
// Read user preference (default show = '1')


// Ensure we have URLs (and meta) for ALL lotteries that appear in savedSets,
// even if they are NOT in Favorites.
$neededIds = array_unique(array_map(static function($s) { return (int)$s->lottery_id; }, $savedSets));

// Figure out which needed IDs are missing from $lottoUrlsById
$currentUrlIds = array_map('intval', array_keys($lottoUrlsById));
$missingIds    = array_values(array_diff($neededIds, $currentUrlIds));

if (!empty($missingIds)) {
    // Build IN() list safely (ints only)
    $idList = implode(',', array_map('intval', $missingIds));

    $q = $db->getQuery(true)
        ->select([
            'l.lottery_id',
            'l.lottery_urls',
            'l.name AS lottery_name',
            's.name AS state_name',
            'c.name AS country_name'
        ])
        ->from($db->quoteName('#__lotteries', 'l'))
        ->join('LEFT', $db->quoteName('#__states', 's') . ' ON l.state_id = s.state_id')
        ->join('LEFT', $db->quoteName('#__countries', 'c') . ' ON s.country_id = c.country_id')
        ->where('l.lottery_id IN (' . $idList . ')');

    $db->setQuery($q);
    $rows = $db->loadAssocList() ?: [];

    foreach ($rows as $row) {
        $id  = (int)($row['lottery_id'] ?? 0);
        $url = trim((string)($row['lottery_urls'] ?? ''));
        if ($id > 0 && $url !== '') {
            $lottoUrlsById[$id] = $url;
        }
        // Also backfill state/country meta when Favorites didn’t provide it
        if (!isset($lottoMetaById[$id])) {
            $lottoMetaById[$id] = [
                'state'   => $row['state_name']   ?? '',
                'country' => $row['country_name'] ?? ''
            ];
        } else {
            // Fill gaps if empty
            if (empty($lottoMetaById[$id]['state']))   { $lottoMetaById[$id]['state']   = $row['state_name']   ?? ''; }
            if (empty($lottoMetaById[$id]['country'])) { $lottoMetaById[$id]['country'] = $row['country_name'] ?? ''; }
        }
    }
}

// --------------------------------------------------------------
// Normalize any non-AI/MCMC/SKAI source back to 'skip_hit'
// so that every weight-variant run still shows as "Skip&Hit"
// --------------------------------------------------------------
foreach ($savedSets as $s) {
    // Map DB value to our 4 buckets
    if ($s->source === 'heatmap_manual') {
        $s->source = 'heatmap';
    } elseif (
        $s->source !== 'ai_prediction' &&
        $s->source !== 'mcmc_prediction' &&
        $s->source !== 'skip_hit' &&
        $s->source !== 'heatmap' &&
        $s->source !== 'skai_prediction'   // NEW: treat SKAI as its own method
    ) {
        // Unknown ? keep old behavior
        $s->source = 'skip_hit';
    }
}

// 2) Load config for actual draws
$configPath = JPATH_ROOT . '/lottery_skip_config.json';
$configData = file_exists($configPath)
    ? json_decode(file_get_contents($configPath),true)
    : [];

// 3) Group by lottery+date
/**
 * Group saved prediction sets by lottery and draw date,
 * and derive draw table metadata per game_id for later lookups.
 */
$groups    = array();
$tableInfo = array();

foreach ($savedSets as $s) {
    // Group key remains lottery_id|next_draw_date; game_id is used for DB lookups.
    $key = $s->lottery_id . '|' . $s->next_draw_date;

    if (!isset($groups[$key])) {
        $groups[$key] = array(
            'lottery_id'   => $s->lottery_id,
            'game_id'      => $s->game_id,
            'lottery_name' => $s->lottery_name,
            'draw_date'    => $s->next_draw_date,
            'preds'        => array(),
        );
    }

    $groups[$key]['preds'][] = $s;

    // Build tableInfo by game_id, not lottery_id, using lottery_skip_config.json.
    if (!isset($tableInfo[$s->game_id])) {
        $spec = $configData['lotteries'][$s->game_id] ?? array();

        $tableInfo[$s->game_id] = array(
            'table' => $spec['dbCol'] ?? '',
            'main'  => $spec['lotteryConfig']['main_ball_columns'] ?? array(),
            'extra' => $spec['lotteryConfig']['extra_ball_column'] ?? null,
        );
    }
}

// Compute the maximum number of main balls and whether any game uses an extra ball.
$maxMain  = 0;
$hasExtra = false;

foreach ($tableInfo as $info) {
    $mainCount = count($info['main']);

    if ($mainCount > $maxMain) {
        $maxMain = $mainCount;
    }

    if (!empty($info['extra'])) {
        $hasExtra = true;
    }
}

// Build UNION ALL query parts for actual draws and construct a preloaded draw map.
$unionParts = array();

foreach ($groups as $g) {
    $tblKeyInt = (int) ($g['game_id'] ?? 0);

    if (!$tblKeyInt || empty($tableInfo[$tblKeyInt]['table'])) {
        continue;
    }

    $tblName = $tableInfo[$tblKeyInt]['table'];
    $tbl     = $db->quoteName($db->replacePrefix($tblName));

    // Build column list: draw_date + aliased mains + optional aliased extra.
    $cols   = array();
    $cols[] = $db->quoteName('draw_date');

    for ($i = 0; $i < $maxMain; $i++) {
        if (!empty($tableInfo[$tblKeyInt]['main'][$i])) {
            // Alias each main ball column to a normalized name: main_0, main_1, …
            $cols[] = $db->quoteName($tableInfo[$tblKeyInt]['main'][$i]) . ' AS main_' . $i; // CHANGED: added alias
        } else {
            $cols[] = 'NULL AS main_' . $i;
        }
    }

    if ($hasExtra) {
        if (!empty($tableInfo[$tblKeyInt]['extra'])) {
            // Alias the extra ball to a normalized name: extra_ball.
            $cols[] = $db->quoteName($tableInfo[$tblKeyInt]['extra']) . ' AS extra_ball'; // CHANGED: added alias
        } else {
            $cols[] = 'NULL AS extra_ball';
        }
    }

    $cols        = implode(',', $cols);
    $escapedDate = $db->quote($g['draw_date']);

    $unionParts[] =
        'SELECT ' . $tblKeyInt . ' AS game_id, ' . $cols . ', ' . $escapedDate . ' AS req_date'
        . ' FROM ' . $tbl
        . ' WHERE ' . $db->quoteName('game_id') . ' = ' . $tblKeyInt
        . ' AND DATE(' . $db->quoteName('draw_date') . ') = ' . $escapedDate;
}

$unionSql = implode(' UNION ALL ', $unionParts);

/**
 * Preload all requested draws into a normalized draw map:
 * $drawMap["<game_id>|<Y-m-d>"] = array(
 *     'game_id'    => int,
 *     'draw_date'  => 'Y-m-d ...',
 *     'main_0'     => int|null,
 *     'main_1'     => int|null,
 *     ...
 *     'extra_ball' => int|null,
 * );
 */
$drawMap = array();

if (!empty($unionSql)) {
    try {
        $db->setQuery($unionSql);
        $rows = (array) $db->loadAssocList();

        foreach ($rows as $row) {
            // Normalize requested date to Y-m-d for consistent keying.
            $reqDate = isset($row['req_date']) ? $row['req_date'] : $row['draw_date'];
            try {
                $dt      = new DateTime($reqDate);
                $norm    = $dt->format('Y-m-d');
            } catch (Exception $e) {
                // Fallback: use raw value if parsing fails.
                $norm = $reqDate;
            }

            $gId     = isset($row['game_id']) ? (int) $row['game_id'] : 0;
            if (!$gId) {
                continue;
            }

            $mapKey = $gId . '|' . $norm;

            // Store the entire row; rendering logic can map fields as needed.
            $drawMap[$mapKey] = $row;
        }
    } catch (RuntimeException $e) {
        // If UNION query fails for any reason, fall back to per-card getDrawByDate().
        $drawMap = array();
    }
}

// ------------------------------------------------------------------
// 6) Compute Best Opportunities per lottery (Agreement / Top-Hits)
//    Uses the preloaded $drawMap as the single data source -- no extra DB queries.
//    Results stored in $bestOpps[lottery_id] for the summary panel.
// ------------------------------------------------------------------

$bestOpps = array();

// Per-game+date draw cache used by the fallback below (avoids repeated DB queries).
$__drawCache = array();

// Shared rank comparator: hits desc -> extra_hits desc -> rank_score desc -> run_id desc
$__rankCompare = function (array $a, array $b) {
    if ($a['hits'] !== $b['hits']) { return $b['hits'] - $a['hits']; }
    if ($a['extra_hits'] !== $b['extra_hits']) { return $b['extra_hits'] - $a['extra_hits']; }
    if ($a['rank_score'] !== $b['rank_score']) { return $b['rank_score'] - $a['rank_score']; }
    return $b['run_id'] - $a['run_id'];
};

foreach ($groups as $groupKey => $g) {
    $lid = (int)$g['lottery_id'];

    if (!isset($bestOpps[$lid])) {
        $bestOpps[$lid] = array(
            'lottery_name'    => (string)($g['lottery_name'] ?? ''),
            'lottery_id'      => $lid,
            'game_id'         => (int)($g['game_id'] ?? 0),
            'state_name'      => (string)($lottoMetaById[$lid]['state'] ?? ''),
            'total_runs'      => 0,
            'best_agreement'  => array('score' => -1, 'draw_date' => '', 'numbers' => array(), 'methods' => array(), 'run_id' => 0, 'source' => ''),
            'best_rank'       => array('score' => -1, 'draw_date' => '', 'run_id' => 0, 'source' => '', 'hits' => 0, 'extra_hits' => 0, 'numbers' => array(), 'extra_number' => 0),
            'all_scored_runs' => array(),
        );
    }
    $bestOpps[$lid]['total_runs'] += count($g['preds']);

    // -- Agreement scoring: numbers shared across different methods --
    $allSourceNumPool = array();
    foreach ($g['preds'] as $s) {
        $src  = (string)$s->source;
        $nums = array_filter(array_map('intval', explode(',', (string)($s->main_numbers ?? ''))));
        if (!isset($allSourceNumPool[$src])) { $allSourceNumPool[$src] = array(); }
        foreach ($nums as $n) { $allSourceNumPool[$src][$n] = true; }
    }
    foreach ($g['preds'] as $s) {
        $src    = (string)$s->source;
        $myNums = array_filter(array_map('intval', explode(',', (string)($s->main_numbers ?? ''))));
        $otherNums = array();
        $otherSrcList = array();
        foreach ($allSourceNumPool as $otherSrc => $numSet) {
            if ($otherSrc !== $src) {
                foreach ($numSet as $n => $_unused) { $otherNums[$n] = true; }
                $otherSrcList[] = $otherSrc;
            }
        }
        $otherSrcList = array_unique($otherSrcList);
        $agreed = array();
        foreach ($myNums as $n) {
            if (isset($otherNums[$n])) { $agreed[] = $n; }
        }
        $score = count($agreed);
        $prev  = $bestOpps[$lid]['best_agreement'];
        $isBetter = ($score > $prev['score'])
            || ($score === $prev['score'] && count($otherSrcList) > count($prev['methods']))
            || ($score === $prev['score'] && count($otherSrcList) === count($prev['methods']) && (int)$s->id > (int)$prev['run_id']);
        if ($isBetter) {
            sort($agreed);
            $bestOpps[$lid]['best_agreement'] = array(
                'score'     => $score,
                'draw_date' => (string)$g['draw_date'],
                'numbers'   => $agreed,
                'methods'   => $otherSrcList,
                'run_id'    => (int)$s->id,
                'source'    => $src,
            );
        }
    }

    // -- Hit scoring: compare each prediction to the actual drawn numbers via $drawMap --
    foreach ($g['preds'] as $s) {
        $predMain = array_values(array_filter(
            array_map('intval', explode(',', (string)($s->main_numbers ?? ''))),
            function ($n) { return $n !== 0; }
        ));
        $predExtra = 0;
        if (isset($s->extra_ball_numbers) && $s->extra_ball_numbers !== '' && $s->extra_ball_numbers !== null) {
            $tmp = array_values(array_filter(array_map('intval', explode(',', (string)$s->extra_ball_numbers))));
            if (!empty($tmp)) { $predExtra = (int)$tmp[0]; }
        }

        $__scored = scoreRunFromDrawMap($drawMap, (int)$g['game_id'], (string)$g['draw_date'], $predMain, $predExtra);

        // ── Fallback: when the UNION-ALL/drawMap path has no data for this
        //    game+date (common for regular lotteries without an extra ball or
        //    when the UNION ALL query failed), fall back to a direct DB lookup –
        //    same two-phase logic used by the per-draw-group rendering code. ──
        if (!$__scored['has_draw']) {
            $__bkTs  = strtotime((string)$g['draw_date']);
            $__bkKey = $g['game_id'] . ':' . ($__bkTs ? date('Y-m-d', $__bkTs) : (string)$g['draw_date']);
            if (!array_key_exists($__bkKey, $__drawCache)) {
                $__bkRow    = getDrawByDate($g['game_id'], (string)$g['draw_date'], $db);
                $__bkMain   = array();
                $__bkExtra  = array();
                if ($__bkRow !== null) {
                    if (array_key_exists('main_0', $__bkRow)) {
                        // Row came from $drawMap (normalized fields)
                        for ($__bi = 0; $__bi < 25; $__bi++) {
                            $__bk = 'main_' . $__bi;
                            if (isset($__bkRow[$__bk]) && $__bkRow[$__bk] !== '' && $__bkRow[$__bk] !== null) {
                                $__bv = (int)$__bkRow[$__bk];
                                if ($__bv) { $__bkMain[] = $__bv; }
                            }
                        }
                        if (isset($__bkRow['extra_ball']) && $__bkRow['extra_ball'] !== '' && $__bkRow['extra_ball'] !== null) {
                            $__bv = (int)$__bkRow['extra_ball'];
                            if ($__bv) { $__bkExtra[] = $__bv; }
                        }
                    } else {
                        // Raw row: use config column names (same as per-card fallback)
                        $__bkFields = getDrawFields($g['game_id']);
                        foreach (($__bkFields['main'] ?? array()) as $__bc) {
                            if (isset($__bkRow[$__bc]) && $__bkRow[$__bc] !== '') { $__bkMain[] = (int)$__bkRow[$__bc]; }
                        }
                        if (!empty($__bkFields['extra']) && isset($__bkRow[$__bkFields['extra']]) && $__bkRow[$__bkFields['extra']] !== '') {
                            $__bkExtra[] = (int)$__bkRow[$__bkFields['extra']];
                        }
                    }
                }
                $__drawCache[$__bkKey] = array('main' => $__bkMain, 'extra' => $__bkExtra);
            }
            $__bkDraw = $__drawCache[$__bkKey];
            if (!empty($__bkDraw['main'])) {
                $__hm = 0; $__he = 0;
                foreach ($predMain as $__pn) { if ($__pn && in_array($__pn, $__bkDraw['main'], true)) $__hm++; }
                if ($predExtra > 0 && !empty($__bkDraw['extra']) && in_array($predExtra, $__bkDraw['extra'], true)) $__he = 1;
                $__scored = array(
                    'has_draw'   => true,
                    'hits_main'  => $__hm,
                    'hits_extra' => $__he,
                    'drawMain'   => $__bkDraw['main'],
                    'drawExtra'  => $__bkDraw['extra'],
                );
            }
        }

        if (!$__scored['has_draw']) {
            continue; // draw not yet available; skip this run
        }

        $mainHitCount  = (int)$__scored['hits_main'];
        $extraHitCount = (int)$__scored['hits_extra'];
        $actualMain    = $__scored['drawMain'];
        $actualExtra   = $__scored['drawExtra'];

        // Position sum for tie-breaking
        $posSum = 0;
        foreach ($predMain as $pos0 => $n) {
            if (in_array($n, $actualMain, true)) {
                $posSum += ($pos0 + 1);
            }
        }
        $rankScore = ($mainHitCount * 10000) - $posSum + ($extraHitCount * 1000);

        $bestOpps[$lid]['all_scored_runs'][] = array(
            'run_id'       => (int)$s->id,
            'game_id'      => (int)$g['game_id'],
            'draw_date'    => (string)$g['draw_date'],
            'source'       => (string)$s->source,
            'hits'         => $mainHitCount,
            'extra_hits'   => $extraHitCount,
            'rank_score'   => $rankScore,
            'pred_main'    => $predMain,
            'pred_extra'   => $predExtra,
            'actual_main'  => $actualMain,
            'actual_extra' => $actualExtra,
            'has_draw'     => true,
        );
    }
}

// Post-process: sort scored runs and promote #1 to best_rank
foreach ($bestOpps as $lid => &$oppRef) {
    if (!empty($oppRef['all_scored_runs'])) {
        usort($oppRef['all_scored_runs'], $__rankCompare);
        $oppWinner = $oppRef['all_scored_runs'][0];
        if (!empty($oppWinner['has_draw'])) {
            $oppRef['best_rank'] = array(
                'score'        => (int)$oppWinner['rank_score'],
                'draw_date'    => (string)$oppWinner['draw_date'],
                'run_id'       => (int)$oppWinner['run_id'],
                'source'       => (string)$oppWinner['source'],
                'hits'         => (int)$oppWinner['hits'],
                'extra_hits'   => (int)$oppWinner['extra_hits'],
                'numbers'      => (array)$oppWinner['pred_main'],
                'extra_number' => (int)$oppWinner['pred_extra'],
                'has_draw'     => true,
            );
        }
    }
}
unset($oppRef);

// Collect winner run IDs for display-name lookup (single query, not per-run)
$__winnerRunIds = array();
foreach ($bestOpps as $__lid => $__opp) {
    $__rid = (int)($__opp['best_rank']['run_id'] ?? 0);
    if ($__rid > 0) { $__winnerRunIds[] = $__rid; }
}
$__winnerRows = array();
if (!empty($__winnerRunIds)) {
    $__wq = $db->getQuery(true)
        ->select('*')
        ->from($db->quoteName('#__user_saved_numbers'))
        ->where($db->quoteName('id')      . ' IN (' . implode(',', array_map('intval', $__winnerRunIds)) . ')')
        ->where($db->quoteName('user_id') . ' = ' . (int)$user->id);
    $db->setQuery($__wq);
    foreach (($db->loadAssocList() ?: array()) as $__wr) {
        $__winnerRows[(int)$__wr['id']] = $__wr;
    }
}

// Compute best-average-hits per lottery (for snapshot cards)
foreach ($bestOpps as $__bavLid => &$__bavOpp) {
    $__bavRuns = $__bavOpp['all_scored_runs'] ?? array();
    if (empty($__bavRuns)) {
        $__bavOpp['best_avg_hits'] = array('run_id' => 0, 'avg_hits' => 0.0, 'scored_runs' => 0, 'last_scored_date' => '', 'display_name' => 'No scored runs yet');
        continue;
    }
    $__bavByRun = array();
    foreach ($__bavRuns as $__bavR) {
        $__rid2 = (int)$__bavR['run_id'];
        if (!isset($__bavByRun[$__rid2])) {
            $__bavByRun[$__rid2] = array('run_id' => $__rid2, 'source' => (string)$__bavR['source'], 'total' => 0, 'count' => 0, 'lastdate' => '');
        }
        $__bavByRun[$__rid2]['total'] += (int)$__bavR['hits'];
        $__bavByRun[$__rid2]['count']++;
        $__d = (string)$__bavR['draw_date'];
        if ($__d !== '' && $__d > $__bavByRun[$__rid2]['lastdate']) {
            $__bavByRun[$__rid2]['lastdate'] = $__d;
        }
    }
    $__bavBest = null;
    foreach ($__bavByRun as $__bavEntry) {
        $__bavAvg = $__bavEntry['count'] > 0 ? ($__bavEntry['total'] / $__bavEntry['count']) : 0;
        if ($__bavBest === null) {
            $__bavBest = $__bavEntry;
            $__bavBest['avg'] = $__bavAvg;
        } else {
            $__prevAvg = $__bavBest['avg'];
            $isBetter2 = ($__bavAvg > $__prevAvg)
                || ($__bavAvg === $__prevAvg && $__bavEntry['total'] > $__bavBest['total'])
                || ($__bavAvg === $__prevAvg && $__bavEntry['total'] === $__bavBest['total'] && $__bavEntry['run_id'] > $__bavBest['run_id']);
            if ($isBetter2) {
                $__bavBest = $__bavEntry;
                $__bavBest['avg'] = $__bavAvg;
            }
        }
    }
    $__bavTotalScored = array_sum(array_column($__bavByRun, 'count'));
    $__bavSrc   = (string)($__bavBest['source'] ?? '');
    $__bavLabel = $__methodLabels[$__bavSrc] ?? ucwords(str_replace('_', ' ', $__bavSrc));
    $__bavWinnerRow = isset($__winnerRows[$__bavBest['run_id']]) ? $__winnerRows[$__bavBest['run_id']] : null;
    $__bavDisplayName = ($__bavWinnerRow !== null)
        ? buildBestSettingsSummary((array)$__bavWinnerRow, $__methodLabels)
        : $__bavLabel;
    $__bavOpp['best_avg_hits'] = array(
        'run_id'           => (int)$__bavBest['run_id'],
        'avg_hits'         => round((float)$__bavBest['avg'], 2),
        'scored_runs'      => $__bavTotalScored,
        'last_scored_date' => (string)($__bavBest['lastdate'] ?? ''),
        'display_name'     => $__bavDisplayName,
    );
}
unset($__bavOpp);

// ------------------------------------------------------------------
// 7) Build per-lottery prediction-results summary for the comparison table.
//    Groups ALL saved runs (scored + unscored) across all draw dates.
//
//    Draw data: uses the preloaded $drawMap (built by the UNION ALL query)
//    as the primary source -- same data used by $bestOpps / scoreRunFromDrawMap.
//    Falls back to a direct getDrawByDate() DB call when $drawMap has no
//    entry for a game+date (e.g. if the UNION ALL failed or returned no row).
// ------------------------------------------------------------------

// Quick lookup: run_id -> display name info (source, mode, label)
$__runDispInfo = array();
foreach ($savedSets as $__s) {
    $__rid = (int)$__s->id;
    $__src = (string)$__s->source;
    $__baseLabel = $__methodLabels[$__src] ?? ucwords(str_replace('_', ' ', $__src));
    $__modeStr = '';
    if ($__src === 'skai_prediction' && !empty($__s->skai_run_mode)) {
        $__modeStr = ucwords(str_replace('_', ' ', (string)$__s->skai_run_mode));
    }
    $__runDispInfo[$__rid] = array(
        'base_label' => $__baseLabel,
        'mode'       => $__modeStr,
        'label'      => !empty($__s->label) ? (string)$__s->label : '',
        'source'     => $__src,
    );
}

// Draw cache keyed by "game_id|Y-m-d": populated once per game+date using
// $drawMap (primary) or getDrawByDate() (fallback).
$__prcDrawCache = array();

// Group all runs per lottery_id
$__runSummary = array();
foreach ($groups as $__gKey => $__g) {
    $__lid = (int)$__g['lottery_id'];
    if (!isset($__runSummary[$__lid])) {
        $__runSummary[$__lid] = array(
            'lottery_name' => (string)($__g['lottery_name'] ?? ''),
            'state_name'   => (string)($lottoMetaById[$__lid]['state'] ?? ''),
            'runs'         => array(),
            'max_hits'     => 0,
            'best_run_id'  => 0,
        );
    }
    // Normalise draw_date to Y-m-d for the cache key.
    $__gDateTs   = strtotime((string)($__g['draw_date'] ?? ''));
    $__gDateNorm = $__gDateTs ? date('Y-m-d', $__gDateTs) : (string)($__g['draw_date'] ?? '');
    $__fbCacheKey = $__g['game_id'] . '|' . $__gDateNorm;

    // ── Fetch draw for this game + draw date (cached per game+date) ──
    // Primary: use the preloaded $drawMap (normalized aliases: main_0, main_1, ..., extra_ball).
    // Fallback: call getDrawByDate() with config column names when $drawMap has no entry.
    if (!array_key_exists($__fbCacheKey, $__prcDrawCache)) {
        $__grpMain  = array();
        $__grpExtra = array();
        if (!empty($drawMap) && isset($drawMap[$__fbCacheKey])) {
            // Use preloaded, normalized row (same source as $bestOpps / scoreRunFromDrawMap)
            $__dmRow = $drawMap[$__fbCacheKey];
            for ($__i = 0; $__i < 25; $__i++) {
                $__mk = 'main_' . $__i;
                if (isset($__dmRow[$__mk]) && $__dmRow[$__mk] !== '' && $__dmRow[$__mk] !== null) {
                    $__gv = (int)$__dmRow[$__mk];
                    if ($__gv !== 0) { $__grpMain[] = $__gv; }
                }
            }
            if (isset($__dmRow['extra_ball']) && $__dmRow['extra_ball'] !== '' && $__dmRow['extra_ball'] !== null) {
                // extra_ball is a single named alias (unlike main_0..N) because there is only one extra ball
                $__gv = (int)$__dmRow['extra_ball'];
                if ($__gv !== 0) { $__grpExtra[] = $__gv; }
            }
        } else {
            // Fallback: direct DB query with config-defined column names.
            // No (int) cast on game_id — matches working sections (Placement Heatmap line 3176, stats block line 3287).
            $__grpFields  = getDrawFields($__g['game_id']);
            $__grpDrawRow = getDrawByDate($__g['game_id'], (string)($__g['draw_date'] ?? ''), $db);
            if ($__grpDrawRow) {
                // Read main ball columns by their config-defined names
                foreach (($__grpFields['main'] ?? array()) as $__gc) {
                    if (isset($__grpDrawRow[$__gc]) && $__grpDrawRow[$__gc] !== '' && $__grpDrawRow[$__gc] !== null) {
                        $__gv = (int)$__grpDrawRow[$__gc];
                        if ($__gv !== 0) { $__grpMain[] = $__gv; }
                    }
                }
                // Read extra ball column (e.g. Powerball, Mega Ball) if configured
                if (!empty($__grpFields['extra'])
                    && isset($__grpDrawRow[$__grpFields['extra']])
                    && $__grpDrawRow[$__grpFields['extra']] !== ''
                    && $__grpDrawRow[$__grpFields['extra']] !== null
                ) {
                    $__gv = (int)$__grpDrawRow[$__grpFields['extra']];
                    if ($__gv !== 0) { $__grpExtra[] = $__gv; }
                }
            }
        }
        $__prcDrawCache[$__fbCacheKey] = array(
            'has_draw'  => !empty($__grpMain),
            'drawMain'  => $__grpMain,
            'drawExtra' => $__grpExtra,
        );
    }
    $__grpDraw = $__prcDrawCache[$__fbCacheKey];

    foreach ($__g['preds'] as $__pred) {
        $__rid = (int)$__pred->id;

        // Parse predicted main numbers (skip zeros)
        $__predNums = array_values(array_filter(
            array_map('intval', explode(',', (string)($__pred->main_numbers ?? ''))),
            function ($n) { return $n !== 0; }
        ));
        // Parse predicted extra ball (Powerball, Mega Ball, etc.)
        $__predExtra = 0;
        if (!empty($__pred->extra_ball_numbers)) {
            $__predExtraVals = array_values(array_filter(array_map('intval', explode(',', (string)$__pred->extra_ball_numbers))));
            if (!empty($__predExtraVals)) { $__predExtra = (int)$__predExtraVals[0]; }
        }

        // ── Score against the direct-DB draw (the sole source for this section) ──
        $__scored = null;
        if ($__grpDraw['has_draw']) {
            $__fbMainHits  = 0;
            foreach ($__predNums as $__fn) {
                if ($__fn !== 0 && in_array($__fn, $__grpDraw['drawMain'], true)) { $__fbMainHits++; }
            }
            $__fbExtraHits = 0;
            if ($__predExtra > 0 && !empty($__grpDraw['drawExtra']) && in_array($__predExtra, $__grpDraw['drawExtra'], true)) {
                $__fbExtraHits = 1;
            }
            $__scored = array(
                'run_id'       => $__rid,
                'hits'         => $__fbMainHits,
                'extra_hits'   => $__fbExtraHits,
                'actual_main'  => $__grpDraw['drawMain'],
                'actual_extra' => $__grpDraw['drawExtra'],
            );
        }

        $__mainHits    = ($__scored !== null) ? (int)$__scored['hits']       : null;
        $__extraHits   = ($__scored !== null) ? (int)$__scored['extra_hits'] : null;
        $__actualMain  = ($__scored !== null) ? ($__scored['actual_main']  ?? array()) : array();
        $__actualExtra = ($__scored !== null) ? ($__scored['actual_extra'] ?? array()) : array();
        $__totalHits = (int)($__mainHits ?? 0) + (int)($__extraHits ?? 0);
        if ($__totalHits > $__runSummary[$__lid]['max_hits']) {
            $__runSummary[$__lid]['max_hits']    = $__totalHits;
            $__runSummary[$__lid]['best_run_id'] = $__rid;
        }
        $__runSummary[$__lid]['runs'][] = array(
            'run_id'        => $__rid,
            'draw_date'     => (string)($__g['draw_date'] ?? ''),
            'source'        => (string)$__pred->source,
            'pred_main'     => $__predNums,
            'pred_extra'    => $__predExtra,
            'actual_main'   => $__actualMain,
            'actual_extra'  => $__actualExtra,
            'hits_main'     => $__mainHits,
            'hits_extra'    => $__extraHits,
            'has_draw'      => ($__scored !== null),
            'disp'          => isset($__runDispInfo[$__rid]) ? $__runDispInfo[$__rid] : array('base_label'=>'','mode'=>'','label'=>'','source'=>$__pred->source),
        );
    }
}

// Sort each lottery's runs: by total hits descending (scored first), then by draw_date desc
foreach ($__runSummary as $__lid => &$__lsRef) {
    usort($__lsRef['runs'], function ($a, $b) {
        // Scored runs before unscored
        if ($a['has_draw'] !== $b['has_draw']) {
            return $a['has_draw'] ? -1 : 1;
        }
        if ($a['has_draw']) {
            $aT = (int)$a['hits_main'] + (int)$a['hits_extra'];
            $bT = (int)$b['hits_main'] + (int)$b['hits_extra'];
            if ($aT !== $bT) { return $bT - $aT; }
        }
        return strcmp((string)$b['draw_date'], (string)$a['draw_date']);
    });
}
unset($__lsRef);

// 5) Analysis types used to render per-method prediction columns.
$modules = array(
    array('key' => 'skip_hit',        'label' => 'Pattern Analysis',      'icon' => '', 'tooltip' => 'Analyzes historical draw patterns'),
    array('key' => 'ai_prediction',   'label' => 'Neural Network',        'icon' => '', 'tooltip' => 'Deep learning model trained on draw history'),
    array('key' => 'mcmc_prediction', 'label' => 'Probability Sampling',  'icon' => '', 'tooltip' => 'Statistical sampling method'),
    array('key' => 'heatmap',         'label' => 'Frequency Map',         'icon' => '', 'tooltip' => 'Visual frequency analysis'),
    array('key' => 'skai_prediction', 'label' => 'Hybrid Model',          'icon' => '', 'tooltip' => 'Combines multiple analytical methods'),
);


?>

<!-- ==================================================
     CSS Styles (Sorcerer [[style]] block)   'lottery_id
     ================================================== -->
[[style]]
/* ──────────────────────────────────────────────────────────────────────
   Design System Variables
────────────────────────────────────────────────────────────────────── */
:root {
  /* SKAI Design System - Calm, Minimal Palette */
  --skai-surface: #ffffff;
  --skai-surface-subtle: #f8fafc;
  --skai-border-subtle: #e2e8f0;
  --skai-border: #cbd5e1;
  --skai-text-primary: #0f172a;
  --skai-text-secondary: #475569;
  --skai-text-muted: #94a3b8;
  --skai-heading: #1e293b;
  --skai-accent: #3b82f6;
  --skai-accent-subtle: #dbeafe;
  --skai-shadow-soft: 0 1px 3px 0 rgba(0, 0, 0, 0.05), 0 1px 2px 0 rgba(0, 0, 0, 0.03);
  --skai-shadow-medium: 0 4px 6px -1px rgba(0, 0, 0, 0.07), 0 2px 4px -1px rgba(0, 0, 0, 0.04);
  
  /* Spacing system (8px base) */
  --space-xs: 0.25rem;
  --space-s: 0.5rem;
  --space-m: 1rem;
  --space-l: 1.5rem;
  --space-xl: 2rem;
  
  /* Typography scale */
  --font-base-size: 16px;
  --line-height-multiplier: 1.5;
  --line-height: calc(var(--font-base-size) * var(--line-height-multiplier));
}

/* ──────────────────────────────────────────────────────────────────────
   Base & Typography
────────────────────────────────────────────────────────────────────── */

#sp-main-body { padding-top: 5px !important; }

body{
  background: var(--skai-surface-subtle);
  color: var(--skai-text-primary);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.6;
  margin: 0;
  padding: 0;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
p, ul, li {
  font-size: 1rem;
  margin: 0 0 1rem 0;
  color: var(--skai-text-secondary);
}
h2.title, h3.title {
  font-weight: 600;
  color: var(--skai-heading);
  margin: 0 0 1rem 0;
  letter-spacing: -0.02em;
}
h2.title { font-size: 1.875rem; }
h3.title { font-size: 1.5rem; }
.lottery-title {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--skai-heading);
  letter-spacing: -0.01em;
}

/* ──────────────────────────────────────────────────────────────────────
   Cards & Containers
────────────────────────────────────────────────────────────────────── */
.card {
  background: var(--skai-surface);
  border: 1px solid var(--skai-border-subtle);
  border-radius: 12px;
  box-shadow: var(--skai-shadow-soft);
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  transition: box-shadow 0.2s ease, border-color 0.2s ease;
}
.card:hover {
  box-shadow: var(--skai-shadow-medium);
  border-color: var(--skai-border);
}
.card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding-bottom: 0.75rem;
  border-bottom: 1px solid var(--skai-border-subtle);
  margin-bottom: 1rem;
}
.card-header .title {
  font-size: 1rem;
  font-weight: 600;
  color: var(--skai-heading);
  letter-spacing: -0.01em;
}
.smart-card{
  border-left:6px solid #f1c40f;
  background:#fffef7;
}

/* Banner */
.banner{
  background:linear-gradient(135deg,#0f172a 0%,#1d4ed8 42%,#0f766e 100%);
  color:#f9fafb;
  padding:1.15rem 1.5rem;
  border-radius:12px;
  box-shadow:0 14px 30px rgba(15,23,42,0.22);
  margin-bottom:1.75rem;
  position:relative;
  overflow:hidden;
}

/* subtle gloss overlay */
.banner::before{
  content:"";
  position:absolute;
  inset:0;
  background:radial-gradient(circle at 0% 0%,rgba(255,255,255,0.22) 0,rgba(255,255,255,0) 45%);
  opacity:.9;
  pointer-events:none;
}

.banner .card-header{
  border-bottom:none;
  padding-bottom:0;
  margin-bottom:0;
}

.banner .title{
  color:#f9fafb!important;
  font-size:1.85rem;
  letter-spacing:.01em;
  margin-bottom:.25rem;
}

.hero-text{
  position:relative;
  z-index:1;
  max-width:640px;
}

.hero-subtitle{
  font-size:.98rem;
  color:#e5e9f5;
  max-width:34rem;
  margin:0;
  line-height:1.55;
}

/* Mobile tightening */
@media (max-width:640px){
  .banner{
    padding:0.95rem 1rem;
    border-radius:10px;
    margin-bottom:1.5rem;
  }
  .banner .title{
    font-size:1.5rem;
  }
  .hero-subtitle{
    font-size;.92rem;
  }
}


/* Lottery logos */
.lotto-logo {
  display:inline-block;
  height:120px;
  width:auto;
  vertical-align:middle;
  border-radius:4px;
  background:#fff;
  border:1px solid #e5e8ec;
  padding:4px;
  box-shadow:0 1px 3px rgba(0,0,0,.06);
  object-fit:contain;
}
.lotto-logo.fallback {
  display:inline-flex;
  align-items:center;
  justify-content:center;
  height:120px; min-width:38px;
  font-weight:800; font-size:14px; color:#2c3e50;
  background:linear-gradient(180deg,#fdfdfd,#f2f4f7);
}
.lotto-title-wrap {
  display:flex; align-items:center; gap:.6rem; flex-wrap:wrap;
}

/* ──────────────────────────────────────────────────────────────────────
   Section Wrappers
────────────────────────────────────────────────────────────────────── */
.favorites-wrapper{ padding:1.5rem; }
.favorite-lotteries-header .btn-primary{ font-size:.9rem; padding:.5rem 1rem; }

.favorites-grid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(280px,1fr)); gap:1.5rem; }
.saved-cards-grid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(300px,1fr)); gap:1.5rem; }
.wheeling-card .card-header{ padding-bottom:.75rem; border-bottom:1px solid #e0e0e5; margin-bottom:1rem; }

/* Legend */
.legend-card{ padding:10; border:none; box-shadow:none; margin-bottom:1rem; }
.legend-card .card-header{ background:transparent; border-bottom:none; padding:.5rem 1rem; }
.legend-container{ display:flex; gap:1rem; padding:.5rem 1rem; }
.legend-box{ position:relative; padding-left:1.6rem; font-weight:600; }
.legend-box.legend-skip::before,
.legend-box.legend-ai::before,
.legend-box.legend-mcmc::before,
.legend-box.legend-heatmap::before{
  content:""; position:absolute; left:0; top:50%; width:.8rem; height:.8rem; transform:translateY(-50%); border-radius:2px;
}
.legend-box.legend-skip::before{ background:#2196f3; }
.legend-box.legend-ai::before{ background:#43a047; }
.legend-box.legend-mcmc::before{ background:#8e24aa; }
.legend-box.legend-heatmap::before{ background:#ef6c00; }

/* Header layout for each prediction card */
.prediction-card .card-header {
  display: grid;
  grid-template-columns: 1fr auto;  /* left grows, right hugs content */
  gap: .5rem 1rem;
  align-items: start;
}

.prediction-card .header-left {
  display: grid;
  grid-template-rows: auto auto;    /* row 1: badges/label, row 2: compare */
  gap: .35rem;
  min-width: 0;
}

.prediction-card .header-badges {
  display: flex;
  align-items: center;
  gap: .75rem;
  flex-wrap: wrap;                  /* wraps nicely on smaller widths */
}

.prediction-card .header-compare {
  display: flex;
  align-items: center;
  gap: .35rem;
  font-size: .85rem;
  color: #333;
}

/* keep the gear fixed at top-right */
.prediction-card .settings-toggle {
  grid-column: 2;
  grid-row: 1 / span 2;
  align-self: start;
  white-space: nowrap;
}

/* Small screens: stack settings under left column, right-aligned */
@media (max-width: 520px) {
  .prediction-card .card-header {
    grid-template-columns: 1fr;
  }
  .prediction-card .settings-toggle {
    grid-column: 1;
    grid-row: auto;
    justify-self: end;
    margin-top: .25rem;
  }
}

/* ──────────────────────────────────────────────────────────────────────
   Buttons & Inputs
────────────────────────────────────────────────────────────────────── */
.btn-primary {
  background: var(--skai-accent);
  color: #fff;
  padding: 0.625rem 1.25rem;
  border: none;
  border-radius: 8px;
  text-decoration: none;
  font-weight: 500;
  font-size: 0.9375rem;
  display: inline-block;
  cursor: pointer;
  transition: background 0.2s ease, transform 0.1s ease;
  letter-spacing: -0.01em;
}
.btn-primary:hover {
  background: #2563eb;
  transform: translateY(-1px);
}
.btn-primary:active {
  transform: translateY(0);
}
.btn-secondary {
  background: var(--skai-surface);
  color: var(--skai-text-primary);
  border: 1px solid var(--skai-border);
  padding: 0.625rem 1.25rem;
  border-radius: 8px;
  font-weight: 500;
  font-size: 0.9375rem;
  cursor: pointer;
  transition: background 0.2s ease, border-color 0.2s ease;
  letter-spacing: -0.01em;
}
.btn-secondary:hover {
  background: var(--skai-surface-subtle);
  border-color: var(--skai-border);
}
.btn-insight {
  font-size: 0.9rem;
  display: inline-block;
  padding: 0.5rem 1rem;
  margin: 0.5rem 0;
}
.filter-input {
  width: 100%;
  padding: 0.625rem 0.875rem;
  border: 1px solid var(--skai-border-subtle);
  border-radius: 8px;
  font-size: 0.9375rem;
  margin-bottom: 1rem;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
.filter-input:focus {
  outline: none;
  border-color: var(--skai-accent);
  box-shadow: 0 0 0 3px var(--skai-accent-subtle);
}

/* Badges */
.section-badge {
  background: var(--skai-accent);
  color: #fff;
  padding: 0.25rem 0.625rem;
  border-radius: 6px;
  font-size: 0.75rem;
  font-weight: 500;
  letter-spacing: 0.02em;
}
.source-badge {
  background: var(--skai-text-secondary);
  color: #fff;
  padding: 0.3rem 0.75rem;
  border-radius: 6px;
  font-size: 0.8125rem;
  font-weight: 500;
  letter-spacing: 0.01em;
  display: inline-block;
  margin-bottom: 0.5rem;
  cursor: help;
  transition: background 0.2s ease;
}
.source-badge:hover {
  background: var(--skai-text-primary);
}

/* Method color themes - Subtle, calm approach */
.prediction-card.skip-hit { background: #f0f9ff; border-left: 3px solid #0ea5e9; }
.prediction-card.ai-prediction { background: #f0fdf4; border-left: 3px solid #22c55e; }
.prediction-card.mcmc-prediction { background: #faf5ff; border-left: 3px solid #a855f7; }
.prediction-card.skai-prediction { background: #ecfeff; border-left: 3px solid #06b6d4; }
.prediction-card.skip-hit .source-badge { background: #0ea5e9; }
.prediction-card.ai-prediction .source-badge { background: #22c55e; }
.prediction-card.mcmc-prediction .source-badge { background: #a855f7; }
.prediction-card.skai-prediction .source-badge { background: #06b6d4; }

/* Heatmap theme */
.prediction-card.heatmap { background: #fff7ed; border-left: 3px solid #f97316; }
.prediction-card.heatmap .source-badge { background: #f97316; }

/* ──────────────────────────────────────────────────────────────────────
   Number pills
────────────────────────────────────────────────────────────────────── */
/* ──────────────────────────────────────────────────────────────────────
   Number pills (fixed so extra matches are GREEN like mains)
────────────────────────────────────────────────────────────────────── */
.drawn-pill, .match-pill, .no-match {
  padding: 1px 7px;
  margin: 2px;
  border-radius: 14px;
  font-size: 12px;
  min-width: 2rem;
  text-align: center;
  font-weight: bold;
  display: inline-block;
}

/* Hits = green */
.match-pill { background:#27ae60; color:#fff; box-shadow:0 0 5px rgba(39,174,96,.4); }
/* Keep extra hits green as well */
.match-pill.extra { background:#27ae60; color:#fff; box-shadow:0 0 5px rgba(39,174,96,.4); }

/* Misses = gray; extra misses = light blue */
.no-match { background:#bdc3c7; color:#060607; opacity:.7; }
.no-match.extra { background:#aed6f1; color:#000; font-weight:700; }

/* Drawn numbers (mains and extras) = green */
.drawn-pill, .drawn-pill.extra {
  background:#27ae60;
  color:#fff;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.6);
}

/* When JS marks “overlap & drawn” it uses .drawn-match; keep that green too */
.drawn-match {
  background:#27ae60;
  color:#fff;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.6);
}

/* Common-across card */
.common-card{ display:none; margin-bottom:1.5rem; }
.common-card .common-numbers{ display:flex; flex-wrap:wrap; gap:.5rem; padding:1rem; }
.common-count{ color:#1f618d; font-weight:600; font-size:1.05rem; }

/* ──────────────────────────────────────────────────────────────────────
   Prediction Grid & Cards
────────────────────────────────────────────────────────────────────── */
.prediction-card,
.prediction-placeholder{
  border-radius:10px;
  padding:5px;
  position:relative;
  transition:box-shadow .2s ease;
  display:flex;
  flex-direction:column;
}

/* Default prediction cards keep their existing theme colors */
.prediction-card{
  background:#fafafa;
  border:1px solid #ccc;
}

.prediction-card:hover{
  box-shadow:0 4px 14px rgba(0,0,0,.1);
}

/* Empty-state placeholder uses SKAI surface + dashed border */
.prediction-placeholder{
  background:var(--skai-surface);
  border:2px dashed var(--skai-border-subtle);
  color:#555;
  text-align:center;
}
.lottery-header{ margin-bottom:1.5rem; }

/* Responsive columns:
   - ≥ 1100px: 3 across
   - 700–1099px: 2 across
   - < 700px: 1 across  */
.predictions-row{
  display: grid;
  gap: 1.5rem;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}

/* cap at 3 columns on wide screens */
@media (min-width: 1100px){
  .predictions-row{ grid-template-columns: repeat(3, 1fr); }
}

@media (min-width:1100px){
  .predictions-row{ grid-template-columns: repeat(3, minmax(0,1fr)); }
}

/* each column stacks its multiple run-cards neatly */
.prediction-column{
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  min-width: 0;      /* prevents grid overflow */
}

/* Placeholder look */
.prediction-placeholder{ background:#fcfcfc; border:2px dashed #d0d0d0; border-radius:8px; box-shadow:inset 0 0 20px rgba(0,0,0,.02); }
.prediction-placeholder .title{ font-size:1.6rem; color:#2c3e50; margin-bottom:1rem; }
.prediction-placeholder p{ font-size:1rem; color:#555; margin-bottom:1.5rem; }
.highlighted-scroll{ outline:3px solid #007BFF; border-radius:6px; transition:outline .3s ease-in-out; }

/* Toggles & comparison controls */

.settings-toggle{
  cursor: pointer;
  font-size: 1rem;
  color: #666;
  transition: transform .2s ease;
}

/* Default = collapsed (no FOUC). JS will add .open when needed */
.settings-panel { display: none !important; }
.settings-panel.open { display: block !important; }

.comparison-footer.form-toolbar{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:1rem;
  margin:1rem 0;
  flex-wrap:wrap;
}

/* Grouping: analysis tools vs archive actions */
.toolbar-group{
  display:flex;
  align-items:center;
  gap:.75rem;
  flex-wrap:wrap;
}

.toolbar-group-archive .toolbar-caption{
  font-size:.8rem;
  text-transform:uppercase;
  letter-spacing:.08em;
  color:#6b7280;
}

/* Sort control */
.form-toolbar .order-form label{
  font-size:.9rem;
  color:#333;
  display:flex;
  align-items:center;
  gap:.4rem;
}
.form-toolbar .order-form select{
  padding:.35rem .6rem;
  font-size:.9rem;
  border:1px solid #ccd1d9;
  border-radius:4px;
  background:#fff;
  cursor:pointer;
}

/* Buttons */
.btn.btn-danger,.btn-danger{
  background:#c0392b; color:#fff; padding:.25rem .6rem; font-size:.8rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; display:inline-block; text-align:center; line-height:1.2;
}
.btn.btn-danger:hover,.btn-danger:hover{ background:#a93226; }

/* Settings grid in each card */
.settings-grid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(180px,1fr)); gap:.5rem; }
.setting-row{
  font-size:.85rem; background:#f9f9f9; border:1px solid #e0e0e0; border-radius:4px;
  padding:.3rem .6rem; display:flex; justify-content:space-between; align-items:center;
}

/* Lottery group as a card */
.lottery-group.card{
  background:#f9f9f9; border:1px solid #e0e0e5; border-radius:8px; overflow:hidden; margin-bottom:2rem;
}
.lottery-group.card .lottery-header{
  background:#e6f2ff; padding:1rem 1.5rem; border-bottom:1px solid #e0e0e5; border-top-left-radius:8px; border-top-right-radius:8px;
}
.lottery-group.card .predictions-row{
  padding:1rem 1.5rem 1.5rem; background:#fff; border-radius:0 0 8px 8px;
}

/* Lottery collapse functionality */
.lottery-collapsible-content {
  transition: max-height 0.3s ease-out, opacity 0.2s ease-out;
  overflow: hidden;
  max-height: 10000px;
  opacity: 1;
}
.lottery-group.collapsed .lottery-collapsible-content {
  max-height: 0;
  opacity: 0;
  overflow: hidden;
}
.lottery-group.collapsed .lottery-header {
  border-bottom: none;
  border-radius: 8px;
}
.lottery-collapse-toggle {
  cursor: pointer;
  transition: transform 0.2s ease;
}
.lottery-group.collapsed .lottery-collapse-toggle {
  transform: rotate(-90deg);
}

/* Collapse helpers */
:root{ --font-base-size:16px; --line-height-multiplier:1.5; --space-s:8px; --color-primary:#1976d2; --line-height:calc(var(--font-base-size)*var(--line-height-multiplier)); }
.card-body .content.collapsible{ display:none!important; }
.card-body .content.collapsible:not(.collapsed){ display:block!important; }
.section-label{ font-weight:bold; display:block; margin:10px 0 5px; }

/* Responsive tweaks */
@media (max-width:640px){
  .comparison-footer{ flex-direction:column; }
  /* do NOT force settings-panel open on mobile */
  /* keep it controlled by the .open class */
}

@media (max-width:480px){
  .drawn-pill,.match-pill,.no-match{ font-size:.85rem; padding:.3rem .5rem; }
}


/* Narrative chips & badges */
.narrative .section-h { font-weight:700; margin:.4rem 0 .25rem; }
.narrative .subtle    { color:#4a5a70; }
.narrative .s-row     { margin:.3rem 0; }
.narrative .bullet    { margin:.15rem 0; }

/* chip container (shared) */
.narrative .chips { display:flex; flex-wrap:wrap; gap:.5rem; margin:.35rem 0 .5rem; padding-bottom:12px; }

/* legacy “chip” (kept for any text chips you still render) */
.narrative .chip {
  display:inline-flex; align-items:center; gap:.35rem;
  padding:.2rem .5rem; border:1px solid #dfe6f2; border-radius:14px;
  font-size:.9rem; background:#f7fafd; color:#1f2a44;
}
.narrative .chip .tags { display:inline-flex; gap:.15rem; }
.narrative .tag {
  font-size:.7rem; font-weight:700; line-height:1;
  padding:.1rem .3rem; border-radius:10px; background:#e9eef7; color:#31405a;
}
.narrative .tag.hit { background:#27ae60; color:#fff; }
.narrative .tag.ovl { background:#1f618d; color:#fff; }
.narrative .tag.ai  { background:#43a047; color:#fff; }
.narrative .tag.sh  { background:#2196f3; color:#fff; }
.narrative .tag.mm  { background:#8e24aa; color:#fff; }
.narrative .tag.hm  { background:#ef6c00; color:#fff; }

/* Lottery-ball styling */
.narrative .ball {
  position: relative;
  width: 42px; height: 42px; border-radius: 50%;
  display: inline-flex; align-items: center; justify-content: center;
  font-weight: 800; font-size: 1rem; color: #0b1320;
  background: radial-gradient(circle at 35% 30%, #ffffff 0%, #f4f4f4 45%, #e1e1e1 100%);
  box-shadow: 0 2px 0 rgba(0,0,0,.15), inset 0 -2px 4px rgba(0,0,0,.08);
  border: 1px solid #cfcfcf;
}

/* badge rail */
.narrative .ball-tags {
  position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%);
  display: inline-flex; gap: 3px;
}
.narrative .btag {
  font-size: .75rem; line-height: 1; font-weight: 800;
  padding: 2px 6px; border-radius: 999px;
  border: none; color: #fff; box-shadow: 0 1px 0 rgba(0,0,0,.25);
  background: #2c3e50;   /* default high-contrast */
}
.narrative .btag.hit { background:#2ecc71; }
.narrative .btag.ovl { background:#1f618d; }
.narrative .btag.ai  { background:#2e7d32; }
.narrative .btag.sh  { background:#1565c0; }
.narrative .btag.mm  { background:#6a1b9a; }
.narrative .btag.hm  { background:#ef6c00; }

/* Tap-friendly, always clickable, sits on top of any overlaps */
.settings-toggle{
  appearance:none;
  background:none;
  border:none;
  padding:.35rem .5rem;
  font:inherit;
  cursor:pointer;
  border-radius:.25rem;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  pointer-events:auto;
  position:relative;
  z-index:2; /* keep above header contents */
}
.settings-toggle:focus{
  outline:2px solid #1976d2;
  outline-offset:2px;
}

[[style]]
/* Give the legend card more breathing room */
.legend-card{
  padding:0.75rem 1.25rem 0.75rem;   /* top / sides / bottom */
}

/* Slight extra space between title and chips */
.legend-card .card-header{
  margin-bottom:0.4rem;
}

/* Lay out the legend items nicely */
.legend-card .legend-container{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:0.75rem 1.5rem;
}

/* Base pill + colored square */
.legend-card .legend-box{
  position:relative;
  padding-left:1.15rem;   /* room for the colored square */
  font-size:0.9rem;
}

.legend-card .legend-box::before{
  content:'';
  position:absolute;
  left:0;
  top:50%;
  transform:translateY(-50%);
  width:10px;
  height:10px;
  border-radius:3px;
}

/* Per-analysis colors (including SKAI) */
.legend-card .legend-box.legend-skip::before{   background-color:#3b82f6; } /* blue */
.legend-card .legend-box.legend-ai::before{     background-color:#22c55e; } /* green */
.legend-card .legend-box.legend-skai::before{   background-color:#06b6d4; } /* teal SKAI */
.legend-card .legend-box.legend-mcmc::before{   background-color:#a855f7; } /* purple */
.legend-card .legend-box.legend-heatmap::before{background-color:#f97316; } /* orange */

[[/style]]



[[/style]]


<!-- ============================================================
     [SKAI-REF-01] Best Settings Snapshot Panel
     Shows best-hit summary for each lottery.
     Populated server-side from $bestOpps (no extra DB queries).
     ============================================================ -->
[[style]]
.skai-global-snapshot {
  background: linear-gradient(135deg, #0A1A33 0%, #162d52 100%);
  border-radius: 12px;
  padding: 14px 18px;
  margin: 0 0 14px 0;
  box-shadow: 0 4px 14px rgba(10,26,51,0.18);
  color: #ffffff;
}
.skai-bss-header { margin-bottom: 10px; }
.skai-bss-title {
  font-size: 1rem;
  font-weight: 800;
  color: #ffffff;
  margin: 0 0 2px 0;
  line-height: 1.2;
}
.skai-bss-subtitle {
  font-size: 0.75rem;
  color: rgba(255,255,255,0.60);
  margin: 0 0 10px 0;
}
.skai-snapshot-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px 16px;
}
@media (max-width: 640px) {
  .skai-snapshot-grid { grid-template-columns: repeat(2, 1fr); }
}
.skai-snapshot-metric {
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 10px;
  padding: 10px 12px;
}
.skai-snapshot-label {
  font-size: 0.7rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: rgba(255,255,255,0.60);
  margin-bottom: 4px;
}
.skai-snapshot-value {
  font-size: 1.05rem;
  font-weight: 800;
  color: #ffffff;
  line-height: 1.2;
}
.skai-best-settings-list {
  margin-top: 12px;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
  gap: 10px;
}
.skai-bss-card {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.14);
  border-radius: 12px;
  padding: 10px 12px;
  width: 300px;
  max-width: 100%;
  box-sizing: border-box;
}
.skai-bss-card__name {
  font-size: 0.92rem;
  font-weight: 800;
  color: #ffffff;
  line-height: 1.2;
  margin-bottom: 2px;
}
.skai-bss-card__method {
  font-size: 0.78rem;
  color: rgba(255,255,255,0.75);
  margin-bottom: 6px;
  line-height: 1.25;
}
.skai-bss-card__metrics {
  display: -webkit-flex;
  display: flex;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
  gap: 6px;
}
.skai-bss-card__metric {
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
  border-radius: 8px;
  padding: 6px 8px;
  min-width: 80px;
}
.skai-bss-card__val {
  display: block;
  font-size: 0.92rem;
  font-weight: 800;
  color: #ffffff;
}
.skai-bss-card__lbl {
  display: block;
  font-size: 0.65rem;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: rgba(255,255,255,0.60);
  margin-top: 2px;
}
.skai-bss-card__date {
  font-size: 0.72rem;
  color: rgba(255,255,255,0.55);
  margin-top: 6px;
}
.skai-bss-card__actions {
  margin-top: 8px;
  display: -webkit-flex;
  display: flex;
  gap: 6px;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}
.skai-bss-view-btn,
.skai-bss-all-link {
  font-size: 0.72rem;
  padding: 4px 10px;
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,0.30);
  background: rgba(255,255,255,0.10);
  color: #ffffff;
  cursor: pointer;
}
.skai-bss-view-btn:hover,
.skai-bss-all-link:hover {
  background: rgba(255,255,255,0.20);
}
.skai-bss-card__spark { margin-top: 8px; }
[[/style]]

<?php
// ── Best Settings Snapshot (server-side render) ──────────────────────
$__snapHasData = false;
foreach ($bestOpps as $__sopp) {
    $__bav = isset($__sopp['best_avg_hits']) ? $__sopp['best_avg_hits'] : null;
    if ($__bav && (int)($__bav['scored_runs'] ?? 0) > 0) { $__snapHasData = true; break; }
}

// Count totals for the summary metrics
$__snapTotalLotteries  = count($bestOpps);
$__snapScoredLotteries = 0;
$__snapTotalScoredRuns = 0;
foreach ($bestOpps as $__sopp) {
    $__bav = isset($__sopp['best_avg_hits']) ? $__sopp['best_avg_hits'] : null;
    if ($__bav && (int)($__bav['scored_runs'] ?? 0) > 0) {
        $__snapScoredLotteries++;
        $__snapTotalScoredRuns += (int)$__bav['scored_runs'];
    }
}
?>

[[div id="skai-global-snapshot" class="skai-global-snapshot" aria-label="Best settings snapshot" role="region"]]
  [[div class="skai-bss-header"]]
    [[h2 class="skai-bss-title"]]Best Settings Snapshot[[/h2]]
    [[p class="skai-bss-subtitle"]]Best-performing settings per lottery (Highest Average Hits).[[/p]]
  [[/div]]
  [[div class="skai-snapshot-grid"]]
    [[div class="skai-snapshot-metric"]]
      [[div class="skai-snapshot-label"]]Active Lotteries[[/div]]
      [[div class="skai-snapshot-value"]]<?php echo (int)$__snapTotalLotteries; ?>[[/div]]
    [[/div]]
    [[div class="skai-snapshot-metric"]]
      [[div class="skai-snapshot-label"]]With Scored History[[/div]]
      [[div class="skai-snapshot-value"]]<?php echo (int)$__snapScoredLotteries; ?>[[/div]]
    [[/div]]
    [[div class="skai-snapshot-metric"]]
      [[div class="skai-snapshot-label"]]Total Scored Runs[[/div]]
      [[div class="skai-snapshot-value"]]<?php echo (int)$__snapTotalScoredRuns; ?>[[/div]]
    [[/div]]
  [[/div]]

  [[div class="skai-best-settings-list"]]
  <?php foreach ($bestOpps as $__sid => $__sopp):
      $__bav = isset($__sopp['best_avg_hits']) ? $__sopp['best_avg_hits'] : null;
      if (!$__bav || (int)($__bav['scored_runs'] ?? 0) <= 0) { continue; }
      $__snapLotName  = htmlspecialchars((string)($__sopp['lottery_name'] ?? ''), ENT_QUOTES, 'UTF-8');
      $__snapMethod   = htmlspecialchars((string)($__bav['display_name'] ?? ''), ENT_QUOTES, 'UTF-8');
      $__snapAvgHits  = number_format((float)($__bav['avg_hits'] ?? 0), 2);
      $__snapScored   = (int)($__bav['scored_runs'] ?? 0);
      $__snapLastDate = htmlspecialchars((string)($__bav['last_scored_date'] ?? ''), ENT_QUOTES, 'UTF-8');
      $__snapRunId    = (int)($__bav['run_id'] ?? 0);
      $__snapBestHits = (int)($__sopp['best_rank']['hits'] ?? 0);
      $__snapBestExtra = (int)($__sopp['best_rank']['extra_hits'] ?? 0);
  ?>
    [[div class="skai-bss-card"]]
      [[div class="skai-bss-card__name"]]<?php echo $__snapLotName; ?>[[/div]]
      <?php if ($__snapMethod !== ''): ?>
        [[div class="skai-bss-card__method"]]<?php echo $__snapMethod; ?>[[/div]]
      <?php endif; ?>
      [[div class="skai-bss-card__metrics"]]
        [[div class="skai-bss-card__metric"]]
          [[span class="skai-bss-card__val"]]<?php echo $__snapAvgHits; ?>[[/span]]
          [[span class="skai-bss-card__lbl"]]Avg Hits[[/span]]
        [[/div]]
        [[div class="skai-bss-card__metric"]]
          [[span class="skai-bss-card__val"]]<?php echo $__snapScored; ?>[[/span]]
          [[span class="skai-bss-card__lbl"]]Scored Runs[[/span]]
        [[/div]]
        <?php if ($__snapBestHits > 0): ?>
        [[div class="skai-bss-card__metric"]]
          [[span class="skai-bss-card__val"]]<?php echo $__snapBestHits; ?>[[/span]]
          [[span class="skai-bss-card__lbl"]]Best Main Hits[[/span]]
        [[/div]]
        <?php endif; ?>
        <?php if ($__snapBestExtra > 0): ?>
        [[div class="skai-bss-card__metric"]]
          [[span class="skai-bss-card__val"]]<?php echo $__snapBestExtra; ?>[[/span]]
          [[span class="skai-bss-card__lbl"]]Best Extra Hit[[/span]]
        [[/div]]
        <?php endif; ?>
      [[/div]]
      <?php if ($__snapLastDate !== ''): ?>
        [[div class="skai-bss-card__date"]]Last scored: <?php echo $__snapLastDate; ?>[[/div]]
      <?php endif; ?>
      [[div class="skai-bss-card__actions"]]
        <?php if ($__snapRunId > 0): ?>
          [[button type="button" class="skai-bss-view-btn"
                   data-jump-run-id="<?php echo $__snapRunId; ?>"
                   data-jump-lottery-id="<?php echo (int)$__sid; ?>"]]View best[[/button]]
        <?php endif; ?>
        [[button type="button" class="skai-bss-all-link"
                 data-jump-crr-id="<?php echo (int)$__sid; ?>"]]All runs[[/button]]
      [[/div]]
    [[/div]]
  <?php endforeach; ?>
  [[/div]]
[[/div]]

<!-- ============================================================
     PREDICTION RESULTS COMPARISON TABLE
     Line-by-line summary per lottery, across all dates.
     Shows every prediction run with hits highlighted.
     ============================================================ -->
[[style]]
/* ── Prediction Results Comparison ─────────────────────────── */
.prc-wrap {
  margin: 0 0 14px 0;
}
.prc-section {
  background: #ffffff;
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  overflow: hidden;
  margin-bottom: 10px;
  box-shadow: 0 2px 8px rgba(15,23,42,0.05);
}
.prc-header {
  display: -webkit-flex;
  display: flex;
  -webkit-align-items: center;
  align-items: center;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  padding: 10px 14px;
  background: linear-gradient(135deg, #0A1A33 0%, #162d52 100%);
  cursor: pointer;
  -webkit-user-select: none;
  user-select: none;
  gap: 10px;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}
.prc-header-left {
  display: -webkit-flex;
  display: flex;
  -webkit-align-items: center;
  align-items: center;
  gap: 8px;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}
.prc-title {
  font-size: 0.9rem;
  font-weight: 800;
  color: #ffffff;
  margin: 0;
  line-height: 1.2;
}
.prc-badge {
  font-size: 0.68rem;
  font-weight: 700;
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(255,255,255,0.12);
  color: #ffffff;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
.prc-badge-best {
  background: rgba(250,204,21,0.85);
  border-color: rgba(234,179,8,0.9);
  color: #1c1400;
}
.prc-toggle-btn {
  font-size: 0.72rem;
  color: rgba(255,255,255,0.75);
  background: rgba(255,255,255,0.10);
  border: 1px solid rgba(255,255,255,0.22);
  border-radius: 6px;
  padding: 3px 10px;
  cursor: pointer;
  white-space: nowrap;
  -webkit-flex-shrink: 0;
  flex-shrink: 0;
}
.prc-body {
  overflow-x: auto;
}
.prc-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  font-size: 0.82rem;
  min-width: 580px;
}
.prc-table thead th {
  background: #f1f5f9;
  color: #1e293b;
  font-size: 0.72rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.07em;
  padding: 7px 9px;
  border-bottom: 2px solid #e2e8f0;
  text-align: left;
  white-space: nowrap;
  position: -webkit-sticky;
  position: sticky;
  top: 0;
  z-index: 1;
}
.prc-table tbody tr {
  border-bottom: 1px solid #f1f5f9;
  -webkit-transition: background 0.12s;
  transition: background 0.12s;
}
.prc-table tbody tr:last-child {
  border-bottom: none;
}
.prc-table tbody tr:hover {
  background: #f8fafc;
}
.prc-table tbody td {
  padding: 6px 9px;
  vertical-align: middle;
  color: #334155;
}
/* Row states */
.prc-row-best {
  background: #fefce8 !important;
  border-left: 3px solid #facc15 !important;
}
.prc-row-best td:first-child { padding-left: 6px; }
.prc-row-hit2 {
  background: #f0fdf4 !important;
}
.prc-row-pending {
  background: #fafafa;
  color: #94a3b8;
}
/* Hit/miss number pills in comparison table */
.prc-num {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 1.6rem;
  height: 1.6rem;
  border-radius: 999px;
  font-size: 0.78rem;
  font-weight: 700;
  border: 1px solid #dde3ef;
  background: #f5f7ff;
  color: #334155;
  margin: 1px;
}
.prc-num-hit {
  background: #16a34a;
  border-color: #15803d;
  color: #ffffff;
}
.prc-num-extra {
  background: #7c3aed;
  border-color: #6d28d9;
  color: #ffffff;
}
.prc-num-extra-miss {
  background: #ede9fe;
  border-color: #ddd6fe;
  color: #5b21b6;
}
/* Source method badge in table */
.prc-src {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 5px;
  font-size: 0.7rem;
  font-weight: 700;
  white-space: nowrap;
}
.prc-src-skip    { background:#e0f2fe; color:#0369a1; border:1px solid #bae6fd; }
.prc-src-ai      { background:#dcfce7; color:#166534; border:1px solid #bbf7d0; }
.prc-src-mcmc    { background:#ede9fe; color:#5b21b6; border:1px solid #ddd6fe; }
.prc-src-skai    { background:#ecfeff; color:#0e7490; border:1px solid #a5f3fc; }
.prc-src-heatmap { background:#fef3c7; color:#92400e; border:1px solid #fde68a; }
/* Hit count cells */
.prc-hits-cell {
  font-size: 0.88rem;
  font-weight: 800;
  color: #1e293b;
  white-space: nowrap;
}
.prc-hits-cell .prc-main { color: #16a34a; }
.prc-hits-cell .prc-extra { color: #7c3aed; }
.prc-hits-zero { color: #94a3b8; font-weight: 400; }
/* Pending "Upcoming" label */
.prc-pending-lbl {
  font-size: 0.75rem;
  color: #94a3b8;
  font-style: italic;
}
/* Trophy icon for best row */
.prc-trophy { margin-right: 2px; }
/* Section heading for "Upcoming draws" within table */
.prc-section-subhead {
  background: #f8fafc;
  color: #64748b;
  font-size: 0.72rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.07em;
  padding: 5px 9px;
  border-top: 1px dashed #e2e8f0;
  border-bottom: 1px solid #e2e8f0;
}
@media (max-width:640px){
  .prc-table { min-width: 420px; }
  .prc-table thead th, .prc-table tbody td { padding: 5px 6px; }
  .prc-num { min-width:1.4rem; height:1.4rem; font-size:0.72rem; }
}
[[/style]]

<?php if (!empty($__runSummary)): ?>
[[div class="prc-wrap" aria-label="Prediction results comparison" role="region"]]

  [[div style="display:-webkit-flex;display:flex;-webkit-align-items:center;align-items:center;gap:8px;margin-bottom:8px;"]]
    [[h2 style="font-size:1rem;font-weight:800;color:#1e293b;margin:0;"]]Prediction Results — Line-by-Line[[/h2]]
    [[span style="font-size:0.78rem;color:#64748b;"]]All runs, all dates. Best hits highlighted.[[/span]]
  [[/div]]

  <?php foreach ($__runSummary as $__prcLid => $__prcData):
      $__prcRuns      = $__prcData['runs'] ?? array();
      if (empty($__prcRuns)) { continue; }
      $__prcLotName   = htmlspecialchars((string)$__prcData['lottery_name'], ENT_QUOTES, 'UTF-8');
      $__prcState     = htmlspecialchars((string)$__prcData['state_name'],   ENT_QUOTES, 'UTF-8');
      $__prcMaxHits   = (int)$__prcData['max_hits'];
      $__prcBestRunId = (int)$__prcData['best_run_id'];
      $__prcTotal     = count($__prcRuns);
      $__prcScored    = 0;
      foreach ($__prcRuns as $__pr) { if ($__pr['has_draw']) { $__prcScored++; } }
      $__prcSectionId = 'prc-sec-' . (int)$__prcLid;
  ?>
  [[div class="prc-section" id="<?php echo $__prcSectionId; ?>"]]
    [[div class="prc-header" onclick="skaiPrcToggle('<?php echo $__prcSectionId; ?>')" role="button" tabindex="0"
          aria-expanded="true" aria-controls="<?php echo $__prcSectionId; ?>-body"
          onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();skaiPrcToggle('<?php echo $__prcSectionId; ?>')}]]

      [[div class="prc-header-left"]]
        [[h3 class="prc-title"]]<?php echo $__prcLotName; ?><?php echo $__prcState ? ' &ndash; ' . $__prcState : ''; ?>[[/h3]]
        [[span class="prc-badge"]]<?php echo $__prcTotal; ?> run<?php echo $__prcTotal !== 1 ? 's' : ''; ?>[[/span]]
        [[span class="prc-badge"]]<?php echo $__prcScored; ?> scored[[/span]]
        <?php if ($__prcMaxHits > 0): ?>
          [[span class="prc-badge prc-badge-best"]]&#x1F3C6; Best: <?php echo $__prcMaxHits; ?> hits[[/span]]
        <?php endif; ?>
      [[/div]]
      [[button type="button" class="prc-toggle-btn" data-prc-id="<?php echo $__prcSectionId; ?>"]]&#x25BC; Collapse[[/button]]
    [[/div]]

    [[div class="prc-body" id="<?php echo $__prcSectionId; ?>-body"]]
      [[table class="prc-table"]]
        [[thead]]
          [[tr]]
            [[th]]#[[/th]]
            [[th]]Draw Date[[/th]]
            [[th]]Method[[/th]]
            [[th]]Mode / Label[[/th]]
            [[th]]Your Numbers[[/th]]
            [[th]]Actual Numbers[[/th]]
            [[th]]Main Hits[[/th]]
            [[th]]Extra[[/th]]
            [[th]]Total[[/th]]
          [[/tr]]
        [[/thead]]
        [[tbody]]
          <?php
          $__prcRowNum   = 0;
          $__prevHasDraw = true;
          foreach ($__prcRuns as $__pr):
              $__prcRowNum++;
              $__prSrc        = (string)$__pr['source'];
              $__prHasD       = (bool)$__pr['has_draw'];
              $__prMainHits   = ($__prHasD && $__pr['hits_main'] !== null)  ? (int)$__pr['hits_main']  : null;
              $__prExtraHits  = ($__prHasD && $__pr['hits_extra'] !== null) ? (int)$__pr['hits_extra'] : null;
              $__prTotal      = (int)($__prMainHits ?? 0) + (int)($__prExtraHits ?? 0);
              $__prIsBest     = ($__prHasD && (int)$__pr['run_id'] === $__prcBestRunId && $__prcMaxHits > 0);
              $__prIs2Plus    = ($__prHasD && (int)($__prMainHits ?? 0) >= 2 && !$__prIsBest);
              $__prRowClass   = $__prIsBest ? 'prc-row-best' : ($__prIs2Plus ? 'prc-row-hit2' : ($__prHasD ? '' : 'prc-row-pending'));

              // Insert separator row before upcoming section
              if ($__prevHasDraw && !$__prHasD):
          ?>
          [[tr]][[td colspan="9" class="prc-section-subhead"]]Upcoming Draws (not yet scored)[[/td]][[/tr]]
          <?php
              endif;
              $__prevHasDraw = $__prHasD;

              // Draw date display
              $__prDateTs  = strtotime((string)$__pr['draw_date']);
              $__prDateStr = $__prDateTs ? date('M j, Y', $__prDateTs) : htmlspecialchars((string)$__pr['draw_date'], ENT_QUOTES, 'UTF-8');

              // Method badge class
              $__prSrcClass = 'prc-src-skip';
              if ($__prSrc === 'ai_prediction')   { $__prSrcClass = 'prc-src-ai'; }
              elseif ($__prSrc === 'mcmc_prediction') { $__prSrcClass = 'prc-src-mcmc'; }
              elseif ($__prSrc === 'skai_prediction') { $__prSrcClass = 'prc-src-skai'; }
              elseif ($__prSrc === 'heatmap')         { $__prSrcClass = 'prc-src-heatmap'; }

              $__prDispInfo   = $__pr['disp'];
              $__prBaseLabel  = htmlspecialchars((string)$__prDispInfo['base_label'], ENT_QUOTES, 'UTF-8');
              $__prMode       = htmlspecialchars((string)$__prDispInfo['mode'],  ENT_QUOTES, 'UTF-8');
              $__prLabel      = htmlspecialchars((string)$__prDispInfo['label'], ENT_QUOTES, 'UTF-8');
              $__prModeLabel  = $__prMode !== '' ? $__prMode : ($__prLabel !== '' ? $__prLabel : '—');
          ?>
          [[tr class="<?php echo $__prRowClass; ?>"]]
            [[td style="color:#94a3b8;font-size:0.75rem;"]]
              <?php if ($__prIsBest): ?>[[span class="prc-trophy"]]&#x1F3C6;[[/span]]<?php endif; ?>
              <?php echo $__prcRowNum; ?>
            [[/td]]
            [[td style="white-space:nowrap;"]]<?php echo $__prDateStr; ?>[[/td]]
            [[td]][[span class="prc-src <?php echo $__prSrcClass; ?>"]]<?php echo $__prBaseLabel; ?>[[/span]][[/td]]
            [[td style="color:#475569;font-size:0.8rem;"]]<?php echo $__prModeLabel; ?>[[/td]]
            [[td]]
              <?php
                // Use array_flip for O(1) lookup instead of O(m) in_array per number
                $__actualLookup      = $__prHasD ? array_flip((array)$__pr['actual_main']) : array();
                $__actualExtraLookup = $__prHasD ? array_flip((array)$__pr['actual_extra']) : array();
                foreach ($__pr['pred_main'] as $__pn):
                  $__pnHit = $__prHasD && isset($__actualLookup[$__pn]);
              ?>[[span class="prc-num <?php echo $__pnHit ? 'prc-num-hit' : ''; ?>"]]<?php echo (int)$__pn; ?>[[/span]]<?php endforeach; ?>
              <?php if ($__pr['pred_extra'] > 0): ?>
                <?php $__predExHit = $__prHasD && isset($__actualExtraLookup[$__pr['pred_extra']]); ?>
                [[span class="prc-num <?php echo $__predExHit ? 'prc-num-extra' : 'prc-num-extra-miss'; ?>" title="Predicted extra ball"]]
                  <?php echo (int)$__pr['pred_extra']; ?>
                [[/span]]
              <?php endif; ?>
            [[/td]]
            [[td]]
              <?php if ($__prHasD && !empty($__pr['actual_main'])): ?>
                <?php
                  // Green for actual numbers that were predicted (matched)
                  $__predLookup = array_flip((array)$__pr['pred_main']);
                  foreach ($__pr['actual_main'] as $__an):
                    $__anHit = isset($__predLookup[(int)$__an]);
                ?>[[span class="prc-num <?php echo $__anHit ? 'prc-num-hit' : ''; ?>"]]<?php echo (int)$__an; ?>[[/span]]<?php endforeach; ?>
                <?php if (!empty($__pr['actual_extra'])): ?>
                  <?php foreach ($__pr['actual_extra'] as $__en):
                    $__enHit = ($__pr['pred_extra'] > 0 && (int)$__en === (int)$__pr['pred_extra']); ?>
                  [[span class="prc-num <?php echo $__enHit ? 'prc-num-extra' : 'prc-num-extra-miss'; ?>"]]<?php echo (int)$__en; ?>[[/span]]<?php endforeach; ?>
                <?php endif; ?>
              <?php elseif (!$__prHasD): ?>
                [[span class="prc-pending-lbl"]]Upcoming[[/span]]
              <?php else: ?>
                [[span class="prc-pending-lbl"]]N/A[[/span]]
              <?php endif; ?>
            [[/td]]
            [[td class="prc-hits-cell"]]
              <?php if ($__prHasD): ?>
                <?php if ($__prMainHits > 0): ?>
                  [[span class="prc-main"]]<?php echo $__prMainHits; ?>[[/span]]
                <?php else: ?>
                  [[span class="prc-hits-zero"]]0[[/span]]
                <?php endif; ?>
              <?php else: ?>
                [[span class="prc-pending-lbl"]]—[[/span]]
              <?php endif; ?>
            [[/td]]
            [[td class="prc-hits-cell"]]
              <?php if ($__prHasD): ?>
                <?php if (!empty($__pr['actual_extra'])): ?>
                  <?php foreach ($__pr['actual_extra'] as $__exn):
                    $__exHit = ($__pr['pred_extra'] > 0 && (int)$__exn === (int)$__pr['pred_extra']); ?>
                  [[span class="prc-num <?php echo $__exHit ? 'prc-num-extra' : 'prc-num-extra-miss'; ?>"]]<?php echo (int)$__exn; ?>[[/span]]
                  <?php if ($__exHit): ?>[[span class="prc-extra"]] &#x2713;[[/span]]<?php endif; ?>
                  <?php endforeach; ?>
                <?php else: ?>
                  [[span class="prc-hits-zero"]]—[[/span]]
                <?php endif; ?>
              <?php else: ?>
                [[span class="prc-pending-lbl"]]—[[/span]]
              <?php endif; ?>
            [[/td]]
            [[td class="prc-hits-cell"]]
              <?php if ($__prHasD): ?>
                <?php if ($__prTotal > 0): ?>
                  [[strong]]<?php echo $__prTotal; ?>[[/strong]]
                <?php else: ?>
                  [[span class="prc-hits-zero"]]0[[/span]]
                <?php endif; ?>
              <?php else: ?>
                [[span class="prc-pending-lbl"]]—[[/span]]
              <?php endif; ?>
            [[/td]]
          [[/tr]]
          <?php endforeach; ?>
        [[/tbody]]
      [[/table]]
    [[/div]]
  [[/div]]
  <?php endforeach; ?>

[[/div]]
<?php endif; ?>

<?php if (empty($groups)): ?>
  [[div class="skai-card prediction-placeholder" style="margin-bottom:2rem; text-align:center; padding:2rem;"]]

    [[h3 class="skai-card__title"]]Start Your Strategy[[/h3]]

    <?php if (empty($favoriteLotteries)): ?>
      [[p style="font-size:1.05rem; color:#666; margin-bottom:1rem;"]]
        You haven’t picked any favorite lotteries yet.
        [[br]]
        Head over to the selection page to get started.
      [[/p]]

<?php $hasFavorites = !empty($favoriteLotteries); ?>

[[button
  type="button"
  class="btn-primary"
  onclick="<?php echo $hasFavorites ? 'scrollToFavorites()' : "window.location.href='/'"; ?>"]]
  ▶️ <?php echo $hasFavorites ? 'Go to Your Favorite Lotteries' : 'Go to Homepage'; ?>
[[/button]]

    <?php else: ?>
      [[p style="font-size:1.05rem; color:#444; margin-bottom:1rem;"]]
        You haven’t saved any predictions yet.
        [[br]]
        To get started, run a prediction (AI, MCMC, or Skip-Hit), and save your results here.
      [[/p]]

      [[a href="/#ai-tools" class="btn-primary"]]
        ▶️ Run a Prediction
      [[/a]]
    <?php endif; ?>

  [[/div]]
<?php endif; ?>

<?php if (! empty($groups) ): ?>

<!-- ==================================================
     Saved Predictions & Numbers Section $unionSql
================================================== -->

<!-- Legend will appear after first prediction group via JavaScript -->
[[div id="legend-card-placeholder" class="skai-card legend-card" style="display:none; margin:1rem 0;"]]
  [[div class="skai-card__header"]]
    [[strong]]Method Colors[[/strong]]
  [[/div]]
  [[div class="legend-container"]]
    [[span class="legend-box legend-skip"]]Pattern Analysis[[/span]]
    [[span class="legend-box legend-ai"]]Neural Network[[/span]]
    [[span class="legend-box legend-skai"]]Hybrid Model[[/span]]
    [[span class="legend-box legend-mcmc"]]Probability Sampling[[/span]]
    [[span class="legend-box legend-heatmap"]]Frequency Map[[/span]]
  [[/div]]
[[/div]]
[[style]]
/* Legend card spacing & title alignment */
.legend-card{
  /* add breathing room under the “How to use this dashboard” card */
  margin-top: 1.25rem;
  border-radius: 10px;
}

/* tighten but balance the header */
.legend-card .card-header{
  padding: 0.4rem 1rem 0.25rem;
}

.legend-card .card-header strong{
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #6b7280;
}
.legend-card .legend-box.legend-skai::before{
  background-color:#06b6d4; /* teal for SKAI */
}

/* give the pills some space inside the card */
.legend-card .legend-container{
  padding: 0.35rem 1rem 0.75rem;
}

/* keep legend items on one “calm” line with nice gaps */
.legend-card .legend-box{
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  margin-right: 1.25rem;
}
[[/style]]

[[div class="skai-card comparison-footer form-toolbar"]]

  [[div class="toolbar-group toolbar-group-analysis"]]
    [[button type="button" id="compare-all-btn" class="btn-primary btn-insight"]]
      Find Common Numbers
    [[/button]]

    [[form method="post" class="order-form"]]
      <?php echo \Joomla\CMS\HTML\HTMLHelper::_('form.token'); ?>
      [[input type="hidden" name="change_sort_dir" value="1"]]
      [[label]]
        View:
        [[select name="pred_sort_dir" onchange="this.form.submit()"]]
          [[option value="desc" <?php echo ($predSortDir==='DESC') ? 'selected' : ''; ?>]]Latest First[[/option]]
          [[option value="asc"  <?php echo ($predSortDir==='ASC') ? 'selected' : ''; ?>]]Oldest First[[/option]]
        [[/select]]
      [[/label]]
    [[/form]]
  [[/div]]

  [[div class="toolbar-group toolbar-group-archive"]]
    [[div class="toolbar-caption"]]
      Archive
    [[/div]]

    [[form
      method="post"
      class="delete-form"
      onsubmit="return confirm('Delete all saved predictions? This cannot be undone.');"]]
      <?php echo \Joomla\CMS\HTML\HTMLHelper::_('form.token'); ?>
      [[input type="hidden" name="delete_all_predictions" value="1"]]
      [[button type="submit" class="btn btn-danger"]]
        Clear All
      [[/button]]
    [[/form]]
  [[/div]]

[[/div]]

<?php foreach ($groups as $g):
  $lottoUrl = $lottoUrlsById[$g['lottery_id']] ?? null;
  $meta     = $lottoMetaById[$g['lottery_id']] ?? [];
  $state    = $meta['state'] ?? '';
  $country  = $meta['country'] ?? '';
?>

[[div class="lottery-group card skai-card" data-lottery-id="<?php echo (int)$g['lottery_id']; ?>-<?php echo htmlspecialchars($g['draw_date'], ENT_QUOTES); ?>"]]
  [[div class="lottery-header skai-card__header" style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:0.5rem;"]]
    [[div style="display:flex; align-items:center; flex:1; flex-wrap:wrap; gap:0.5rem;"]]

<?php
  // Build logo for this group (uses state name & lottery name from your meta)
  $logo = ['path'=>'','exists'=>false,'alt'=>''];
  if (!empty($state) && !empty($g['lottery_name'])) {
      $logo = buildLotteryLogoPath((string)$state, (string)$g['lottery_name']);
  }
?>

[[div class="lotto-title-wrap"]]
  <?php if (!empty($logo['path'])): ?>
    <?php if ($logo['exists']): ?>
      [[img class="lotto-logo" src="<?php echo htmlspecialchars($logo['path'], ENT_QUOTES); ?>"
            alt="<?php echo htmlspecialchars($logo['alt'], ENT_QUOTES); ?>" loading="lazy" width="120" height="38"]]
    <?php else: ?>
      [[span class="lotto-logo fallback" aria-label="<?php echo htmlspecialchars($logo['alt'].' (placeholder)', ENT_QUOTES); ?>"]]
        <?php
          // simple fallback initials from lottery name (2 letters)
          $parts = preg_split('/\s+/', (string)$g['lottery_name']);
          $ini   = '';
          foreach ($parts as $p) { if ($p !== '') { $ini .= mb_strtoupper(mb_substr($p,0,1)); if (mb_strlen($ini) >= 2) break; } }
          echo htmlspecialchars($ini ?: 'LE', ENT_QUOTES);
        ?>
      [[/span]]
    <?php endif; ?>
  <?php endif; ?>

[[h2 class="lottery-title skai-card__title" style="margin:0;"]]
  [[span class="lottery-name"]]
    <?php if ($country) echo htmlspecialchars($country, ENT_QUOTES); ?>
  [[/span]]

  <?php if ($state && $state !== 'Lottery'): ?>
    &nbsp;•&nbsp;
    [[span class="lottery-name"]]
      <?php echo htmlspecialchars($state, ENT_QUOTES); ?>
    [[/span]]
  <?php endif; ?>

<?php
  // Resolve a correct lottery name (Powerball, Mega Millions, etc.)
  $lotName = '';
  if (!empty($g['lottery_name'])) {
      $lotName = $g['lottery_name'];
  } elseif (!empty($g['game_name'])) {
      $lotName = $g['game_name'];
  } elseif (!empty($s->lottery_name)) {
      $lotName = $s->lottery_name;
  }
?>

<?php if (!empty($lotName)): ?>
  &nbsp;•&nbsp;
  [[span class="lottery-name"]]
    <?php echo htmlspecialchars($lotName, ENT_QUOTES); ?>
  [[/span]]
<?php endif; ?>

  &nbsp;•&nbsp;
  <?php
    $ts = strtotime((string) ($g['draw_date'] ?? ''));
    echo $ts ? date('M j, Y', $ts) : htmlspecialchars((string) ($g['draw_date'] ?? ''), ENT_QUOTES);
  ?>
[[/h2]]

[[/div]]

  <!-- disabled “Pick Another Analysis” button -->
<?php if ($lottoUrl): ?>
  [[a href="<?php echo htmlspecialchars($lottoUrl, ENT_QUOTES); ?>"
       target="_blank"
       rel="noopener"
       class="btn-primary"
       style="margin-left:1rem; font-size:0.75rem; padding:0.25rem 0.6rem;"]]
    🎯 Official Results Page
  [[/a]]
<?php endif; ?>


[[form method="post"
       style="margin-left:.5rem; display:inline-block;"
       onsubmit="return confirm('Delete all predictions for this draw?');"]]
  <?php echo \Joomla\CMS\HTML\HTMLHelper::_('form.token'); ?>
  [[input type="hidden" name="delete_lottery_predictions" value="1"]]
  [[input type="hidden" name="lottery_id" value="<?php echo (int)$g['lottery_id']; ?>"]]
  [[input type="hidden" name="draw_date"  value="<?php echo htmlspecialchars($g['draw_date'], ENT_QUOTES); ?>"]]
  [[button type="submit" class="btn-danger" style="padding:0.25rem 0.6rem; font-size:0.75rem;"]]
    🗑️ Delete This Draw
  [[/button]]
[[/form]]
    [[/div]]
    
    [[button type="button" class="lottery-collapse-toggle btn-secondary" 
             style="padding:0.35rem 0.75rem; font-size:0.8rem; white-space:nowrap;"
             aria-expanded="true"
             aria-label="Collapse lottery section"]]
      ▼ Collapse
    [[/button]]
  [[/div]]
  
  [[div class="lottery-collapsible-content"]]

      <?php
        // ──────────────────────────────────────────────────────────────
        // GROUP-LEVEL: Placement & Performance Stats (per lottery/draw)
        // Derives rank positions from the order of saved main_numbers.
        // ──────────────────────────────────────────────────────────────

        // Build per-method buckets for this group
$methodKeys = ['skip_hit','ai_prediction','mcmc_prediction','skai_prediction','heatmap'];
        $predsBySource = [];
        foreach ($g['preds'] as $__r) { $predsBySource[$__r->source][] = $__r; }

        // Fetch single actual draw row for the group (once)
$__fields   = getDrawFields($g['game_id']);

// Normalize date for drawMap lookup
$__normDate = $g['draw_date'];
try {
    $dt = new DateTime($g['draw_date']);
    $__normDate = $dt->format('Y-m-d');
} catch (Exception $e) {
    $__normDate = $g['draw_date'];
}

$__drawKey = (int)$g['game_id'] . '|' . $__normDate;

// Use preloaded $drawMap first; fallback to getDrawByDate()
if (!empty($drawMap) && isset($drawMap[$__drawKey])) {
    $__drawRow = $drawMap[$__drawKey];
} else {
    $__drawRow = getDrawByDate($g['game_id'], $g['draw_date'], $db);
}

$__drawMain = [];
$__drawExtra = [];

if ($__drawRow) {

  // If row came from $drawMap, normalized fields exist (main_0, main_1, …, extra_ball)
  $hasNormalizedMains = array_key_exists('main_0', $__drawRow);

  if ($hasNormalizedMains) {
      // Read normalized main fields
      for ($i = 0; $i < 25; $i++) { // 25 = safe max; unused indexes ignored
          $key = 'main_' . $i;
          if (isset($__drawRow[$key]) && $__drawRow[$key] !== '' && $__drawRow[$key] !== null) {
              $__drawMain[] = (int)$__drawRow[$key];
          }
      }

      // Normalized extra ball (optional)
      if (isset($__drawRow['extra_ball']) && $__drawRow['extra_ball'] !== '' && $__drawRow['extra_ball'] !== null) {
          $__drawExtra[] = (int)$__drawRow['extra_ball'];
      }

  } else {
      // FALLBACK MODE: use original column names from config
      foreach (($__fields['main'] ?? []) as $__c) {
          if (isset($__drawRow[$__c]) && $__drawRow[$__c] !== '') {
              $__drawMain[] = (int)$__drawRow[$__c];
          }
      }

      if (!empty($__fields['extra']) &&
          isset($__drawRow[$__fields['extra']]) &&
          $__drawRow[$__fields['extra']] !== '') {
          $__drawExtra[] = (int)$__drawRow[$__fields['extra']];
      }
  }
}

        // Limits: up to 20 main ranks, up to 5 extra ranks (safe defaults)
        $__maxRankMain  = 20;
        $__maxRankExtra = 5;

        // Initialize stats
        $placementStats = [];
        $hitsByMethod   = [];
        $predCountByMethod = [];
        foreach ($methodKeys as $__m) {
          $placementStats[$__m] = [
            'main'  => array_fill(1, $__maxRankMain, 0),
            'extra' => array_fill(1, $__maxRankExtra, 0),
            'main_hits_total'  => 0,
            'extra_hits_total' => 0
          ];
          $hitsByMethod[$__m] = ['runs'=>0,'mainHits'=>0,'extraHits'=>0];
          $predCountByMethod[$__m] = isset($predsBySource[$__m]) ? count($predsBySource[$__m]) : 0;
        }

        $totalRuns = count($g['preds']);
        $totalMainHits = 0;
        $totalExtraHits = 0;

        // Helper: map number -> position (1-based) for a prediction string
        $toPositions = function (string $csv, int $limit) {
          $arr = array_values(array_filter(array_map('trim', explode(',', $csv)), fn($v)=>$v!==''));
          $pos = [];
          foreach ($arr as $i => $n) {
            if ($i >= $limit) break;
            $num = (int)$n;
            if (!isset($pos[$num])) { $pos[$num] = $i + 1; } // first occurrence = rank
          }
          return $pos;
        };

        // (old placement stats block removed – see GROUP-LEVEL
        // Placement & Performance Stats block below for the
        // live implementation)
      ?>

      <?php
        // ──────────────────────────────────────────────────────────────
        // GROUP-LEVEL: Placement & Performance Stats (per lottery/draw)
        // Derives rank positions from the order of saved main_numbers.
        // Also sets pre/post mode based on whether the actual draw exists.
        // ──────────────────────────────────────────────────────────────

        // Build per-method buckets for this group
$methodKeys = ['skip_hit','ai_prediction','mcmc_prediction','skai_prediction','heatmap'];
        $predsBySource = [];
        foreach ($g['preds'] as $__r) { $predsBySource[$__r->source][] = $__r; }

        // Fetch single actual draw row for the group (once)
        $__fields   = getDrawFields($g['game_id']);
        $__drawRow  = getDrawByDate($g['game_id'], $g['draw_date'], $db);
        $__drawMain = [];
        $__drawExtra = [];
        if ($__drawRow) {
          foreach (($__fields['main'] ?? []) as $__c) {
            if (isset($__drawRow[$__c]) && $__drawRow[$__c] !== '') { $__drawMain[] = (int)$__drawRow[$__c]; }
          }
          if (!empty($__fields['extra']) && isset($__drawRow[$__fields['extra']]) && $__drawRow[$__fields['extra']] !== '') {
            $__drawExtra[] = (int)$__drawRow[$__fields['extra']];
          }
        }

        // Mode: pre (no draw yet) vs post (draw completed)
        $__mode = $__drawRow ? 'post' : 'pre';

        // Limits: up to 20 main ranks, up to 5 extra ranks
        $__maxRankMain  = 20;
        $__maxRankExtra = 5;

        // Initialize stats
        $placementStats = [];
        $hitsByMethod   = [];
        $predCountByMethod = [];
        foreach ($methodKeys as $__m) {
          $placementStats[$__m] = [
            'main'  => array_fill(1, $__maxRankMain, 0),
            'extra' => array_fill(1, $__maxRankExtra, 0),
            'main_hits_total'  => 0,
            'extra_hits_total' => 0
          ];
          $hitsByMethod[$__m] = ['runs'=>0,'mainHits'=>0,'extraHits'=>0];
          $predCountByMethod[$__m] = isset($predsBySource[$__m]) ? count($predsBySource[$__m]) : 0;
        }

        $totalRuns = count($g['preds']);
        $totalMainHits = 0;
        $totalExtraHits = 0;

        // Helper: map number -> position (1-based) for a prediction string
        $toPositions = function (string $csv, int $limit) {
          $arr = array_values(array_filter(array_map('trim', explode(',', $csv)), fn($v)=>$v!==''));
          $pos = [];
          foreach ($arr as $i => $n) {
            if ($i >= $limit) break;
            $num = (int)$n;
            if (!isset($pos[$num])) { $pos[$num] = $i + 1; } // first occurrence = rank
          }
          return $pos;
        };

        // Crunch stats across all runs in this group
        foreach ($g['preds'] as $__run) {
          $src   = $__run->source;
          if (!in_array($src,$methodKeys,true)) { $src = 'skip_hit'; }
          $hitsByMethod[$src]['runs']++;

          // Build position maps for this run
          $posMain  = $toPositions((string)($__run->main_numbers ?? ''), $__maxRankMain);
          $posExtra = $toPositions((string)($__run->extra_ball_numbers ?? ''), $__maxRankExtra);

          // Compare to actual draw mains (only meaningful if post mode)
          foreach ($__drawMain as $__hit) {
            if (isset($posMain[$__hit])) {
              $rank = (int)$posMain[$__hit];
              if ($rank >= 1 && $rank <= $__maxRankMain) {
                $placementStats[$src]['main'][$rank]++;
                $placementStats[$src]['main_hits_total']++;
                $hitsByMethod[$src]['mainHits']++;
                $totalMainHits++;
              }
            }
          }

          // Compare to actual extra(s)
          foreach ($__drawExtra as $__e) {
            if (isset($posExtra[$__e])) {
              $rankE = (int)$posExtra[$__e];
              if ($rankE >= 1 && $rankE <= $__maxRankExtra) {
                $placementStats[$src]['extra'][$rankE]++;
                $placementStats[$src]['extra_hits_total']++;
                $hitsByMethod[$src]['extraHits']++;
                $totalExtraHits++;
              }
            }
          }
        }

        // Compute method "sweet spots": top 2 rank positions by main hit count
        $sweetSpots = [];
        foreach ($methodKeys as $__m) {
          $row = $placementStats[$__m]['main'];
          arsort($row);
          $tops = array_slice(array_keys($row), 0, 2);
          $tops = array_values(array_filter($tops, fn($k) => $placementStats[$__m]['main'][$k] > 0));
          $sweetSpots[$__m] = $tops; // e.g., [4,7]
        }

        // Averages
        $avgMainHitsPerRun  = $totalRuns ? round($totalMainHits / $totalRuns, 2) : 0;
        $avgExtraHitsPerRun = $totalRuns ? round($totalExtraHits / $totalRuns, 2) : 0;

        // Short labels
        $labelShort = [
          'skip_hit'        => 'Skip & Hit',
          'ai_prediction'   => 'AI',
          'mcmc_prediction' => 'MCMC',
          'skai_prediction' => 'SKAI',      // ← NEW
          'heatmap'         => 'Heatmap',
        ];
      ?>

[[style]]
/* ── Placement Heatmap (mains) ───────────────────────────────────── */
.placement-wrap{
  display:flex;
  flex-direction:column;
  gap:0.75rem;
  margin:1.25rem 0;
}
.placement-grid{
  overflow:auto;
  border-radius:10px;
  border:1px solid #dde3f0;
  background:linear-gradient(135deg,#f9fbff 0,#ffffff 45%,#f3f4fb 100%);
  box-shadow:0 10px 22px rgba(15,23,42,0.05);
}
.placement-grid table{
  border-collapse:separate;
  border-spacing:0;
  width:100%;
  min-width:520px;
  font-variant-numeric:tabular-nums;
}
.placement-grid th,
.placement-grid td{
  border:1px solid #e0e0e5;
  padding:.35rem .5rem;
  text-align:center;
  font-size:.85rem;
}

/* Header row */
.placement-grid thead th{
  position:sticky;
  top:0;
  background:linear-gradient(180deg,#f3f6ff 0,#e9efff 50%,#e3e9fb 100%);
  z-index:2;
  font-size:.8rem;
  font-weight:700;
  color:#1f2937;
  letter-spacing:.04em;
  text-transform:uppercase;
  border-bottom-color:#cbd5f1;
}

/* First & last columns (labels + total) */
.placement-grid thead th:first-child,
.placement-grid tbody td:first-child{
  text-align:left;
  padding-left:.7rem;
  font-weight:700;
  background:rgba(248,250,252,0.9);
  position:sticky;
  left:0;
  z-index:3;
}
.placement-grid thead th:last-child,
.placement-grid tbody td:last-child{
  font-weight:700;
  background:rgba(249,250,251,0.98);
}

/* zero values = pale cell so you can still see the grid */
.placement-grid td.zero{
  background:#F5F7FB;
  color:#556;
}

.placement-grid td{
  position:relative;
  letter-spacing:.2px;
  transition:
    box-shadow .12s ease,
    transform .08s ease,
    border-color .12s ease;
}

/* Peak outline stays as your gold “target” */
.placement-grid td.cell-peak{
  box-shadow:inset 0 0 0 2px #ffb000;
}

/* Row hover — subtle lift without killing inline heat colors */
.placement-grid tbody tr:hover td{
  border-color:#cbd5f5;
}
.placement-grid tbody tr:hover td:not(.zero){
  box-shadow:inset 0 0 0 1px rgba(15,23,42,0.08);
}

/* Helper narrative text below/above tables */
.helper{
  font-size:.95rem;
  color:#2c3e50;
  line-height:1.5;
}

/* ============================================================
   WORLD-CLASS UI PRIMITIVES: BALLS, TAGS, BULLETS, SECTIONS
   ============================================================ */

/* Generic badges (used for PURE-SKIP + gray ID tags) */
.badge{
  background:#eef4ff;
  color:#204a8e;
  border:1px solid #cfdaf5;
  padding:.15rem .5rem;
  border-radius:999px;
  font-size:.8rem;
  font-weight:600;
}
.badge.gray{
  background:#f6f6f6;
  color:#444;
  border-color:#e0e0e0;
}
.badge.pure-badge{
  background:#ffe9cc;
  color:#7a3e00;
  border:1px solid #ffc680;
  letter-spacing:.2px;
}

/* Number pills / “balls” */
.ball{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  min-width:2rem;
  height:2rem;
  padding:0 .55rem;
  border-radius:999px;
  background:#f5f7ff;
  border:1px solid #d6dcf4;
  font-size:.9rem;
  font-weight:600;
  color:#1f2937;
  letter-spacing:.01em;
  box-shadow:0 1px 1px rgba(30,58,138,0.04);
}
.ball-hit{
  background:#16a34a;
  border-color:#15803d;
  color:#ffffff;
}
.ball-ovl{
  background:#1d4ed8;
  border-color:#1e3a8a;
  color:#ffffff;
}

/* Tag chips under numbers (HIT / OVL / AI / SH / MCMC / HM) */
.btag{
  display:inline-block;
  padding:0.15rem 0.45rem;
  margin:0.15rem 0;
  border-radius:6px;
  font-size:.7rem;
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:.04em;
  color:#1e293b;
  background:#f2f4f7;
  border:1px solid #d3d8df;
}
.btag-hit{
  background:#16a34a;
  border-color:#15803d;
  color:#ffffff;
}
.btag-ovl{
  background:#1d4ed8;
  border-color:#1e40af;
  color:#ffffff;
}
/* Method-specific tag colors — aligned with card headers */
.btag-ai{
  /* AI = green */
  background:#dcfce7;
  border-color:#bbf7d0;
  color:#166534;
}
.btag-sh{
  /* Skip & Hit = blue */
  background:#e0f2fe;
  border-color:#bfdbfe;
  color:#1d4ed8;
}
.btag-mm{
  /* MCMC = purple */
  background:#ede9fe;
  border-color:#ddd6fe;
  color:#5b21b6;
}
.btag-hm{
  /* Heatmap = orange */
  background:#fef3c7;
  border-color:#fed7aa;
  color:#92400e;
}

/* Chip rows */
.chips{
  display:flex;
  flex-wrap:wrap;
  gap:0.35rem .5rem;
  margin-top:0.25rem;
}
.ball-tags{
  display:flex;
  flex-wrap:wrap;
  gap:0.25rem;
  margin-top:0.25rem;
}

/* Coverage row under Common Agreement Bar */
.coverage-row{
  margin-top:0.75rem;
  padding-top:0.5rem;
  border-top:1px dashed #e2e8f0;
}
.coverage-label{
  font-size:0.82rem;
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:0.06em;
  color:#6b7280;
  margin-bottom:0.25rem;
}

/* Section headers for narrative/card blocks */
.section-h{
  font-size:1rem;
  font-weight:700;
  margin-bottom:0.35rem;
  color:#1f2a3a;
  letter-spacing:0.01em;
}
.s-row{
  margin-bottom:0.35rem;
}
.s-row.subtle{
  font-size:0.9rem;
  color:#475569;
}
.bullet{
  margin-left:1rem;
  color:#374151;
  font-size:.88rem;
  margin-bottom:0.3rem;
  line-height:1.45;
}

/* Divider for narrative sections */
.narrative-divider{
  border-top:1px solid #e3e7ef;
  margin:0.75rem 0;
}

/* ── Decision Strip (world-class top bar) ───────────────────────── */
.decision-strip{
  border:1px solid #dde3f0;
  border-radius:10px;
  padding:0.9rem 1rem 0.85rem;
  margin:1.25rem 0 0.75rem;
  background:linear-gradient(135deg,#f8fbff 0%,#f4f7ff 45%,#f8fbff 100%);
  display:flex;
  flex-direction:column;
  gap:0.6rem;
}
.decision-strip-header{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:0.75rem;
  flex-wrap:wrap;
}
.decision-strip-main-title{
  display:flex;
  align-items:center;
  gap:0.5rem;
  font-size:0.95rem;
  font-weight:600;
  color:#1f2933;
}
.decision-strip-main-title .label{
  letter-spacing:0.02em;
  text-transform:uppercase;
  font-size:0.78rem;
  opacity:0.85;
}
.badge-soft{
  display:inline-flex;
  align-items:center;
  padding:0.1rem 0.55rem;
  border-radius:999px;
  font-size:0.75rem;
  border:1px solid #d5e0ff;
  background:#eef2ff;
  color:#243b80;
  font-weight:600;
}
.decision-strip-meta{
  display:flex;
  flex-direction:column;
  align-items:flex-end;
  gap:0.2rem;
  font-size:0.78rem;
  color:#4b5563;
  text-align:right;
}
.decision-strip-meta .meta-label{
  font-weight:600;
}
.decision-strip-meta .meta-value{
  margin-left:0.25rem;
}
.decision-strip-meta .meta-note{
  font-size:0.75rem;
  opacity:0.85;
}

.decision-strip-body{
  display:flex;
  flex-wrap:wrap;
  gap:0.75rem 1.2rem;
  align-items:flex-start;
  border-top:1px solid #e2e8f8;
  padding-top:0.55rem;
}
.decision-group{
  min-width:210px;
}
.decision-label{
  display:block;
  font-size:0.8rem;
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:0.04em;
  color:#6b7280;
  margin-bottom:0.25rem;
}
.decision-pills{
  display:flex;
  flex-wrap:wrap;
  gap:0.35rem;
}
.decision-pill{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  min-width:2.1rem;
  padding:0.15rem 0.5rem;
  border-radius:999px;
  font-size:0.82rem;
  font-weight:600;
  background:#f3f4ff;
  color:#1f2933;
  border:1px solid #d5ddff;
}
.decision-pill-extra{
  background:#fff7ed;
  border-color:#fed7aa;
}
.decision-pill-hit{
  background:#16a34a;
  border-color:#15803d;
  color:#ffffff;
  box-shadow:0 0 0 1px rgba(15,118,110,.25);
}
.decision-pill-overlap{
  background:#1d4ed8;
  border-color:#1e40af;
  color:#ffffff;
}
.decision-pill-empty{
  background:#f9fafb;
  border-style:dashed;
  border-color:#d1d5db;
  color:#6b7280;
  font-weight:500;
}

/* Common “agreement bar” styling */
.prediction-card.common-card{
  border-style:dashed;
  border-color:#c4d1f5;
  background:linear-gradient(135deg,#f8fbff 0%,#fdfdff 48%,#f5f7ff 100%);
  padding-top:0.75rem;
  padding-bottom:0.75rem;
  margin-bottom:1.25rem;
}
.prediction-card.common-card .card-header{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:0.75rem;
  flex-wrap:wrap;
  margin-bottom:0.35rem;
}
.common-title-main{
  display:flex;
  align-items:center;
  gap:0.35rem;
  font-size:0.95rem;
  font-weight:700;
  color:#111827;
}
.common-title-main .label{
  font-size:0.78rem;
  letter-spacing:.06em;
  text-transform:uppercase;
  color:#6b7280;
}
.common-title-sub{
  font-size:0.82rem;
  color:#4b5563;
  margin-top:0.1rem;
}
.prediction-card.common-card .common-count{
  display:inline-flex;
  align-items:center;
  padding:0.15rem 0.6rem;
  border-radius:999px;
  font-size:0.78rem;
  font-weight:600;
  background:#eef2ff;
  border:1px solid #d4ddff;
  color:#1d3a8a;
  white-space:nowrap;
}

/* Area where JS injects overlapping numbers */
.common-numbers{
  padding:0.6rem 0.25rem 0.15rem;
  border-top:1px dashed #dbe3f7;
  margin-top:0.25rem;
}
.common-numbers > div{
  margin-bottom:0.25rem;
  font-size:0.85rem;
  color:#374151;
}
/* Overlap highlight (SKAI/LottoExpert pill) */
.common-highlight{
  display:inline-flex;
  align-items:center;
  justify-content:center;

  border-radius:999px;
  padding:0.18rem 0.6rem;
  margin:0.12rem 0.18rem 0.12rem 0;

  background:#1C66FF;           /* SKAI Blue */
  border:1px solid rgba(28,102,255,0.35);
  color:#fff;
  font-weight:700;
  font-size:0.92rem;
  line-height:1;
  min-width:2.2rem;

  box-shadow:0 6px 18px rgba(10,26,51,0.10);
  transition:transform .12s ease, box-shadow .12s ease, filter .12s ease;
}

/* Clickable “pick” behavior for Decision Set */
.le-pick-pill{
  cursor:pointer;
  user-select:none;
}
.le-pick-pill:hover{
  transform:translateY(-1px);
  box-shadow:0 10px 22px rgba(10,26,51,0.14);
}
.le-pick-pill:focus{
  outline:2px solid rgba(28,102,255,0.45);
  outline-offset:2px;
}

/* Selected state (same base styling, slightly stronger clarity) */
/* =========================================================
   Decision Builder — grid pills: selected must be obvious
   ========================================================= */

/* Base grid pills (unselected): calm, readable */
.prediction-panel .le-pick-pill.common-highlight{
  background:#EFF6FF;              /* very light blue tint */
  border:1px solid #BFDBFE;        /* light outline */
  color:#0A1A33;                   /* Deep Navy */
  box-shadow:none;
  transition:transform .08s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease, color .12s ease;
}

/* Hover/focus affordance for accessibility */
.prediction-panel .le-pick-pill.common-highlight:hover{
  border-color:#60A5FA;
  box-shadow:0 1px 4px rgba(10,26,51,.10);
}
.prediction-panel .le-pick-pill.common-highlight:focus{
  outline:3px solid rgba(28,102,255,.35); /* SKAI Blue ring */
  outline-offset:2px;
}

/* SELECTED state: high-contrast SKAI Blue + crisp ring */
.prediction-panel .le-pick-pill.le-is-selected{
  background:#1C66FF !important;   /* SKAI Blue */
  border-color:#0A1A33 !important; /* Deep Navy border for contrast */
  color:#FFFFFF !important;
  box-shadow:
    0 6px 14px rgba(10,26,51,.18),
    0 0 0 2px rgba(255,255,255,.85) inset; /* inner ring */
  transform:translateY(-1px);
}

/* Selected + hover: slightly stronger, still tasteful */
.prediction-panel .le-pick-pill.le-is-selected:hover{
  box-shadow:
    0 8px 18px rgba(10,26,51,.22),
    0 0 0 2px rgba(255,255,255,.90) inset;
}

/* Selected chips in the “Decision pool” display should also be obvious */
.prediction-panel .le-pick-selected.le-is-selected,
.prediction-panel .le-pick-selected.common-highlight{
  background:#1C66FF !important;
  border:1px solid #0A1A33 !important;
  color:#FFFFFF !important;
  box-shadow:0 6px 14px rgba(10,26,51,.16);
}
.le-pick-selected{
  cursor:pointer;
  user-select:none;
}

/* When an overlapping number is ALSO a drawn hit */
.drawn-match{
  background:#16a34a !important;
  border-color:#15803d !important;
  color:#ffffff !important;
  box-shadow:0 0 0 1px rgba(15,118,110,.35);
}

/* Slight tightening for mobile */
@media (max-width:640px){
  .decision-strip{
    padding:0.8rem 0.8rem 0.75rem;
  }
  .decision-strip-body{
    flex-direction:column;
    gap:0.5rem;
  }
}

/* ============================================================
   WC-010: subtle micro-animations (respects reduced motion)
   ============================================================ */
@media (prefers-reduced-motion: no-preference){
  .ball,
  .decision-pill,
  .btag,
  .prediction-card,
  .btn-primary,
  .btn-insight{
    transition:
      transform 150ms ease-out,
      box-shadow 150ms ease-out,
      background-color 150ms ease-out,
      border-color 150ms ease-out,
      color 150ms ease-out;
  }

  .prediction-card:hover{
    transform:translateY(-1px);
    box-shadow:0 6px 14px rgba(15,23,42,0.08);
  }

  .btn-primary:hover,
  .btn-insight:hover{
    transform:translateY(-0.5px);
    box-shadow:0 4px 10px rgba(30,64,175,0.22);
  }

  .ball:hover,
  .decision-pill:hover{
    transform:translateY(-0.5px);
    box-shadow:0 3px 8px rgba(15,23,42,0.12);
  }

  .btag:hover{
    transform:translateY(-0.25px);
    box-shadow:0 2px 6px rgba(15,23,42,0.08);
  }
}

/* ============================================================
   WC-011: Print / export friendly layout
   ============================================================ */
@media print{
  /* Reset backgrounds & shadows for clean PDF output */
  body,
  .prediction-panel,
  .lottery-group,
  .prediction-card,
  .common-card,
  .decision-strip{
    background:#ffffff !important;
    box-shadow:none !important;
  }

  .card,
  .prediction-card,
  .common-card,
  .decision-strip{
    border-color:#999999 !important;
  }

  .helper,
  .narrative,
  .section-h,
  .bullet,
  .decision-strip,
  .decision-strip-body,
  .decision-strip-header,
  .decision-strip-main-title{
    color:#000000 !important;
  }

  /* Keep tables crisp on paper */
  .placement-grid table,
  .placement-grid th,
  .placement-grid td{
    border-color:#444444 !important;
  }

  /* Simplify heatmap colors slightly in print for clarity */
  .placement-grid td.zero{
    background:#f3f4f6 !important;
    color:#374151 !important;
  }

  /* Hide purely interactive chrome */
  .btn-primary,
  .btn-insight,
  .card-compare-checkbox,
  .settings-toggle,
  .favorite-lotteries-header a,
  .wheeling-card a.btn-primary{
    display:none !important;
  }

  /* Avoid truncated chips / balls across pages */
  .chips,
  .common-numbers,
  .decision-strip-body{
    page-break-inside:avoid;
  }

  .prediction-card,
  .lottery-group{
    page-break-inside:avoid;
    margin-bottom:1.2rem;
  }

  /* Make sure narrative prints full width */
  .narrative-card,
  [data-narrative]{
    max-width:100% !important;
  }
}


/* ============================================================
   WORLD-CLASS PREDICTION CARD SHELL
   Scoped to the prediction panel to avoid touching other cards
   ============================================================ */

.prediction-panel .prediction-card{
  display:flex;
  flex-direction:column;
  gap:0.45rem;
  padding:0.9rem 0.95rem 0.95rem;
  border-radius:12px;
  border:1px solid #dde3f0;
  background:
    radial-gradient(160% 240% at 0% 0%, #f9fbff 0, #ffffff 46%, #f3f4fb 100%);
  box-shadow:0 8px 18px rgba(15,23,42,0.05);
  transition:
    box-shadow .18s ease,
    transform .18s ease,
    border-color .18s ease,
    background .18s ease;
}
.prediction-panel .prediction-card:hover{
  transform:translateY(-1px);
  box-shadow:0 12px 26px rgba(15,23,42,0.09);
  border-color:#c4d0ed;
}

/* Per-method subtle accent (Skip & Hit / AI / MCMC / Heatmap / SKAI) */
.prediction-panel .prediction-card.skip-hit{
  border-left:3px solid #16a34a;
}
.prediction-panel .prediction-card.ai-prediction{
  border-left:3px solid #2563eb;
}
.prediction-panel .prediction-card.mcmc-prediction{
  border-left:3px solid #7c3aed;
}
.prediction-panel .prediction-card.heatmap{
  border-left:3px solid #f97316;
}
/* NEW: SKAI method accent */
.prediction-panel .prediction-card.skai-prediction{
  border-left:3px solid #0ea5e9;
}

/* Header layout */
.prediction-panel .prediction-card .card-header{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:0.75rem;
  margin-bottom:0.2rem;
}
.prediction-panel .prediction-card .header-left{
  display:flex;
  flex-direction:column;
  gap:0.3rem;
}
.prediction-panel .prediction-card .header-badges{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:0.35rem;
}

/* Source badge (AI, Skip & Hit, etc.) */
.prediction-panel .prediction-card .source-badge{
  display:inline-flex;
  align-items:center;
  gap:0.35rem;
  padding:0.18rem 0.55rem;
  border-radius:999px;
  background:#eef2ff;
  border:1px solid #d4ddff;
  font-size:.8rem;
  font-weight:700;
  color:#1d2e7c;
  letter-spacing:.03em;
}

/* Compare checkbox label */
.prediction-panel .prediction-card .header-compare{
  display:inline-flex;
  align-items:center;
  gap:0.3rem;
  font-size:.8rem;
  color:#4b5563;
  cursor:pointer;
}
.prediction-panel .prediction-card .header-compare input[type="checkbox"]{
  width:1rem;
  height:1rem;
  border-radius:4px;
}

/* Settings toggle button */
.prediction-panel .prediction-card .settings-toggle{
  border:none;
  background:rgba(15,23,42,0.02);
  border-radius:999px;
  padding:0.25rem 0.75rem;
  font-size:.78rem;
  font-weight:600;
  letter-spacing:.02em;
  display:inline-flex;
  align-items:center;
  gap:0.25rem;
  cursor:pointer;
  color:#1f2937;
  border:1px solid rgba(148,163,184,0.7);
  transition:
    background .15s ease,
    color .15s ease,
    border-color .15s ease,
    transform .12s ease;
}
.prediction-panel .prediction-card .settings-toggle:hover{
  background:#111827;
  color:#f9fafb;
  border-color:#111827;
  transform:translateY(-0.5px);
}

/* Settings panel: smooth collapse/expand */
.prediction-panel .prediction-card .settings-panel{
  max-height:0;
  overflow:hidden;
  opacity:0;
  transform:translateY(-3px);
  transition:
    max-height .22s ease,
    opacity .18s ease,
    transform .18s ease;
}
.prediction-panel .prediction-card .settings-panel.open{
  max-height:600px; /* comfortably above any expected content */
  opacity:1;
  transform:translateY(0);
}

/* Settings grid inside panel */
.prediction-panel .settings-grid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:0.2rem 0.75rem;
  margin-top:0.1rem;
}
@media (max-width:768px){
  .prediction-panel .settings-grid{
    grid-template-columns:1fr;
  }
}
.prediction-panel .setting-row{
  font-size:.78rem;
  color:#374151;
  display:flex;
  justify-content:space-between;
  gap:0.4rem;
}

/* Drawn numbers & prediction pills */
.prediction-panel .drawn-pill,
.prediction-panel .match-pill,
.prediction-panel .no-match{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  min-width:1.9rem;
  height:1.9rem;
  padding:0 .5rem;
  margin:0.08rem 0.18rem 0.08rem 0;
  border-radius:999px;
  border:1px solid #e5e7eb;
  font-size:.88rem;
  font-weight:600;
  letter-spacing:.01em;
  box-shadow:0 1px 1px rgba(15,23,42,0.03);
}

/* Actual drawn numbers (main) */
.prediction-panel .drawn-pill{
  background:#111827;
  border-color:#030712;
  color:#f9fafb;
}
.prediction-panel .drawn-pill.extra{
  background:#0f172a;
  border-color:#020617;
}

/* Predicted numbers – non-hit */
.prediction-panel .no-match{
  background:#f3f4f6;
  color:#4b5563;
}

/* Predicted numbers – hit */
.prediction-panel .match-pill{
  background:#dcfce7;
  border-color:#16a34a;
  color:#14532d;
}

/* Common overlap highlight (not drawn) — used ONLY for overlap/agreements, not the manual grid */
.prediction-panel .common-highlight{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  min-width:2.1rem;
  padding:0.15rem 0.5rem;
  border-radius:999px;
  font-size:0.82rem;
  font-weight:800;
  background:#1d4ed8;              /* strong overlap signal */
  border:1px solid #1e40af;
  color:#ffffff;
}

/* =========================================================
   Decision Builder — manual number pools (Main/Extra grids)
   ========================================================= */

/* Base grid pill (unselected): calm “button” */
/* =========================================================
   Decision Builder — manual number pools (Main/Extra grids)
   Scope to .lottery-group so it works everywhere in My LottoExpert
   ========================================================= */

.lottery-group .le-pick-pill{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  min-width:44px;
  height:40px;
  padding:0 10px;
  border-radius:999px;
  font-weight:800;
  font-size:0.9rem;
  color:#0A1A33;                   /* Deep Navy */
  background:#FFFFFF;
  border:1px solid #D7DEE9;
  box-shadow:0 1px 2px rgba(10,26,51,.08);
  cursor:pointer;
  user-select:none;
  transition:transform .08s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease, color .12s ease;
}

.lottery-group .le-pick-pill:hover{
  border-color:#1C66FF;            /* SKAI Blue */
  box-shadow:0 4px 10px rgba(10,26,51,.14);
  transform:translateY(-1px);
}

.lottery-group .le-pick-pill:focus{
  outline:3px solid rgba(28,102,255,.35);
  outline-offset:2px;
}

/* SELECTED: obvious SKAI Blue + inner white ring */
.lottery-group .le-pick-pill.le-is-selected{
  background:#1C66FF !important;   /* SKAI Blue */
  border-color:#0A1A33 !important; /* Deep Navy */
  color:#FFFFFF !important;
  box-shadow:
    0 10px 18px rgba(10,26,51,.22),
    0 0 0 3px rgba(255,255,255,.92) inset; /* inner ring */
  transform:translateY(-1px);
}

/* Drawn + overlap “super hit” */
.prediction-panel .drawn-match{
  background:#111827 !important;
  border-color:#1d4ed8 !important;
  color:#f9fafb !important;
  box-shadow:0 0 0 2px rgba(37,99,235,0.5);
}

/* Placeholder card styling */
.prediction-panel .prediction-placeholder{
  background:#f9fafb;
  border-style:dashed;
  border-color:#cbd5e1;
  box-shadow:none;
}
.prediction-panel .prediction-placeholder .btn-insight{
  margin-top:0.35rem;
}

/* Column layout refinements (scoped to prediction panel only) */
.prediction-panel .predictions-row{
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:1rem;
}
@media (max-width:1024px){
  .prediction-panel .predictions-row{
    grid-template-columns:repeat(2,minmax(0,1fr));
  }
}
@media (max-width:640px){
  .prediction-panel .predictions-row{
    grid-template-columns:1fr;
  }
}
.prediction-panel .prediction-column{
  display:flex;
  flex-direction:column;
  gap:0.75rem;
}

/* (deduped: common-card alignment is handled by the base
   .prediction-card.common-card rules defined above) */

/* Favorite scroll highlight helper */
.highlighted-scroll{
  animation:lxHighlight 1.6s ease-out;
}
@keyframes lxHighlight{
  0%{ box-shadow:0 0 0 0 rgba(59,130,246,0.35); }
  100%{ box-shadow:0 0 0 12px rgba(59,130,246,0); }
}

[[/style]]

[[div class="card decision-strip" data-decision-strip]]
  [[div class="decision-strip-header"]]
    [[div class="decision-strip-main-title"]]
      [[span class="label"]]Decision for this draw[[/span]]
      [[span class="badge badge-soft" data-decision-mode-label]]Upcoming draw[[/span]]
    [[/div]]
    [[div class="decision-strip-meta" data-decision-confidence-wrap]]
      [[span class="meta-label"]]
        Confidence:
        [[span class="meta-value" data-decision-confidence]]Calibrating…[[/span]]
      [[/span]]
      [[span class="meta-note" data-decision-note]]
        Based on agreement between methods and proven hot spots.
      [[/span]]
    [[/div]]
  [[/div]]
  [[div class="decision-strip-body"]]
    <!-- DISABLED: Recommended Mains section
         Reason: Currently shows only raw numbers with no dashes and is confusing.
         This section has been commented out to prevent display.
         Code preserved for potential future re-enabling if improved.
    [[div class="decision-group"]]
      [[span class="decision-label"]]Recommended mains[[/span]]
      [[div class="decision-pills" data-decision-mains]]
        [[span class="decision-pill decision-pill-empty"]]
          Waiting for your selected methods…
        [[/span]]
      [[/div]]
    [[/div]]
    END DISABLED: Recommended Mains section -->
    <!-- DISABLED: Recommended Extras section
         Reason: Currently shows bunched up numbers similar to mains issue.
         This section has been commented out to prevent display.
         Code preserved for potential future re-enabling if improved.
    [[div class="decision-group" data-decision-extra-block style="display:none;"]]
      [[span class="decision-label"]]Recommended extras[[/span]]
      [[div class="decision-pills" data-decision-extras]]
        [[span class="decision-pill decision-pill-empty"]]
          No extra ball recommendations yet
        [[/span]]
      [[/div]]
    [[/div]]
    END DISABLED: Recommended Extras section -->
  [[/div]]
[[/div]]

<!-- ============ PLACEMENT HEATMAP (Mains) ============ -->
[[div class="card placement-wrap"]]
  [[div class="card-header"]]
    [[h3 class="title"]]Placement Performance Heatmap (Mains)[[/h3]]
  [[/div]]

  [[div class="helper" style="margin:.5rem 0 1rem; font-size:.95rem; color:#2c3e50; line-height:1.5;"]]
    [[strong]]What this shows:[[/strong]]
    Each [[em]]row[[/em]] is one method (Skip &amp; Hit, AI, MCMC, Heatmap).
    Each [[em]]column[[/em]] is a rank position: #1 is your first choice, #20 is a later pick.
    The numbers in the cells are [[em]]how many times the actual winning numbers landed in that rank[[/em]] across all saved runs for this draw.
    [[br]][[br]]
    [[strong]]How to read it:[[/strong]]
    [[br]]
    • The [[strong]]red side on the left (low rank numbers)[[/strong]] shows early picks.  
    • The [[strong]]blue side on the right (high rank numbers)[[/strong]] shows later picks.  
    • Darker cells mean [[em]]more hits[[/em]] at that rank.  
    • Gold-outlined cells mark each method’s current [[em]]“sweet-spot” ranks[[/em]].
    [[br]][[br]]


    [[strong]]Goal:[[/strong]]
    You want your best methods to stack hits in the #1–#5 columns early instead of “finding them by accident” in the late ranks.
  [[/div]]


  <?php


  /* ---------- PHP helpers for color & readability ---------- */
  if (!function_exists('hslToHex')) {
    function hslToHex(float $h, float $s, float $l): string {
      $h = fmod(max(0, min(360, $h)), 360) / 360.0;
      $s = max(0, min(100, $s)) / 100.0;
      $l = max(0, min(100, $l)) / 100.0;

      $r = $l; $g = $l; $b = $l;
      if ($s != 0) {
        $q = ($l < 0.5) ? ($l * (1 + $s)) : ($l + $s - $l * $s);
        $p = 2 * $l - $q;
        $r = hue2rgb($p, $q, $h + 1/3);
        $g = hue2rgb($p, $q, $h);
        $b = hue2rgb($p, $q, $h - 1/3);
      }
      return sprintf('#%02X%02X%02X', (int)round($r * 255), (int)round($g * 255), (int)round($b * 255));
    }
    function hue2rgb($p, $q, $t) {
      if ($t < 0) $t += 1;
      if ($t > 1) $t -= 1;
      if ($t < 1/6) return $p + ($q - $p) * 6 * $t;
      if ($t < 1/2) return $q;
      if ($t < 2/3) return $p + ($q - $p) * (2/3 - $t) * 6;
      return $p;
    }
  }
  if (!function_exists('textColorForHex')) {
    function textColorForHex(string $hex): array {
      $hex = ltrim($hex, '#');
      if (strlen($hex) === 3) $hex = $hex[0].$hex[0].$hex[1].$hex[1].$hex[2].$hex[2];
      $r = hexdec(substr($hex, 0, 2));
      $g = hexdec(substr($hex, 2, 2));
      $b = hexdec(substr($hex, 4, 2));
      $lum = (0.2126*$r + 0.7152*$g + 0.0722*$b) / 255;
      if ($lum < 0.55) { return ['#FFFFFF', '0 1px 0 rgba(0,0,0,.35)']; }
      return ['#111111', '0 1px 0 rgba(255,255,255,.35)'];
    }
  }
  ?>

  [[div class="placement-grid"]]
    [[table]]
      [[thead]]
        [[tr]]
          [[th style="text-align:left;"]]Method[[/th]]
          <?php for ($c=1; $c<=$__maxRankMain; $c++): ?>
            [[th]]<?php echo $c; ?>[[/th]]
          <?php endfor; ?>
          [[th]]Row Total[[/th]]
        [[/tr]]
      [[/thead]]
      [[tbody]]
        <?php
          // For slight intensity boost, we still compute a global max (only affects lightness tweak).
          $globalMax = 0;
          foreach ($methodKeys as $__m) {
            $maxInRow = max($placementStats[$__m]['main'] ?: [0]);
            if ($maxInRow > $globalMax) $globalMax = $maxInRow;
          }
          if ($globalMax <= 0) $globalMax = 1;

          foreach ($methodKeys as $__m):
            $row = $placementStats[$__m]['main'];
            $rowTotal = array_sum($row);

            // Peak columns (optional: keeps your gold outline logic)
            arsort($row);
            $peakCols = array_slice(array_keys($row), 0, 2);
            $peakCols = array_values(array_filter($peakCols, fn($k)=>$placementStats[$__m]['main'][$k] > 0));
        ?>
        [[tr]]
          [[td style="text-align:left; font-weight:700;"]]
            <?php echo htmlspecialchars($labelShort[$__m], ENT_QUOTES); ?>
          [[/td]]

          <?php for ($c=1; $c<=$__maxRankMain; $c++):
            $val = (int)($row[$c] ?? 0);

            if ($val === 0) {
              $cls   = 'zero';
              $style = '';
            } else {
              // === RANK → COLOR mapping ===
              // rank #1 (leftmost) -> Hue 0 (red) ; rank #20 (rightmost) -> Hue 240 (blue)
              $t    = ($__maxRankMain > 1) ? (($c - 1) / ($__maxRankMain - 1)) : 0; // 0..1
              $hue  = 0 + (240 * $t);                // 0=red → 240=blue

              // Slight intensity boost by count: higher counts = a bit darker (lower lightness)
              $ratio = $val / $globalMax;            // 0..1
              $light = 52 - (min(1, max(0, $ratio)) * 8); // 52%..44%

              $bg    = hslToHex($hue, 90, $light);
              [$txt, $shadow] = textColorForHex($bg);
              $cls   = '';
              $style = 'background:'.$bg.';color:'.$txt.';font-weight:700;text-shadow:'.$shadow.';';
            }

            $peakCls = in_array($c, $peakCols, true) ? ' cell-peak' : '';
          ?>
            [[td class="<?php echo $cls . $peakCls; ?>" style="<?php echo $style; ?>" title="Hits at rank #<?php echo $c; ?>: <?php echo $val; ?>"]]
              <?php echo $val; ?>
            [[/td]]
          <?php endfor; ?>

          [[td style="font-weight:700;"]]
            <?php echo (int)$rowTotal; ?>
          [[/td]]
        [[/tr]]
        <?php endforeach; ?>
      [[/tbody]]
    [[/table]]
  [[/div]]

  <!-- Optional mini legend -->
  [[div style="margin-top:.35rem; font-size:.85rem; color:#444;"]]
    [[span style="display:inline-block; width:16px; height:10px; background:#FF0000; margin-right:.35rem;"]][[/span]] Rank #1 (hot)
    &nbsp;→&nbsp;
    [[span style="display:inline-block; width:16px; height:10px; background:#0000FF; margin:0 .35rem 0 .55rem;"]][[/span]] Rank #<?php echo $__maxRankMain; ?> (cool)
    &nbsp;•&nbsp; Gold outline = peak columns for that method
  [[/div]]
  
  <?php
  // ===== Dynamic takeaway: best method, tie-break by earliest (lowest) hit rank =====
  // We scan each method's placement row, count total hits, and track how early
  // (low rank) the first hit appears. Ties in total hits are broken by who hits earlier.
  $best = [
      'method'   => null,
      'total'    => -1,
      'bestRank' => PHP_INT_MAX,
  ];
  $perMethodSummaries = [];

  foreach ($methodKeys as $__m) {
      // Main placement row for this method
      $row       = $placementStats[$__m]['main'] ?? [];
      $totalHits = array_sum($row);

      // Find earliest (lowest) rank where this method has at least one hit
      $earliest = PHP_INT_MAX;
      for ($r = 1; $r <= $__maxRankMain; $r++) {
          if (!empty($row[$r])) {
              $earliest = $r;
              break;
          }
      }

      // Find latest (highest) rank where this method has a hit
      $latest = 0;
      for ($r = $__maxRankMain; $r >= 1; $r--) {
          if (!empty($row[$r])) {
              $latest = $r;
              break;
          }
      }

      // Update "best" method:
      // 1) Highest total hits wins
      // 2) If tied, the method that hits earlier (lower rank) wins
      if (
          $totalHits > $best['total']
          || ($totalHits === $best['total'] && $earliest < $best['bestRank'])
      ) {
          $best['method']   = $__m;
          $best['total']    = $totalHits;
          $best['bestRank'] = $earliest;
      }

      // Human-friendly range text, e.g. "#2–#11" or "—" if no hits
      $rangeText = ($earliest !== PHP_INT_MAX && $latest > 0)
          ? ('#' . $earliest . '–#' . $latest)
          : '—';

      $label = $labelShort[$__m] ?? $__m;
      $perMethodSummaries[] = $label . ': total ' . (int) $totalHits . ' hits, range ' . $rangeText;
  }

  // Compose the headline + advice based on how early the best method hits
  $bestLabel    = $best['method'] ? ($labelShort[$best['method']] ?? $best['method']) : '—';
  $bestTotal    = max(0, (int) $best['total']);
  $bestRankText = ($best['bestRank'] === PHP_INT_MAX) ? 'n/a' : '#' . $best['bestRank'];

  if ($best['bestRank'] !== PHP_INT_MAX && $best['bestRank'] <= 5) {
      $advice = 'Great: your best method is hitting in the red zone (#1–#5). Keep tuning to push more hits into #1–#3.';
  } elseif ($best['bestRank'] !== PHP_INT_MAX && $best['bestRank'] <= 10) {
      $advice = 'Decent: hits are appearing mid-rank. Try adjusting settings to pull more into #1–#5.';
  } else {
      $advice = 'Heads-up: hits are mostly late (blue side). Explore other settings to improve early-rank placement.';
  }
  ?>

[[div class="helper" style="margin-top:.75rem; padding:.85rem 1.05rem; background:#f7fbff; border:1px solid #dfe6f2; border-radius:8px;"]]
  [[div style="font-weight:700; margin-bottom:0.25rem; font-size:0.95rem; color:#1f2a3a; letter-spacing:0.01em;"]]
    Smart Takeaway for this draw
  [[/div]]

  [[div style="font-size:0.9rem; margin-bottom:0.35rem;"]]
    [[strong]]Best performer:[[/strong]]
    [[strong]]<?php echo htmlspecialchars($bestLabel, ENT_QUOTES); ?>[[/strong]]
    with [[strong]]<?php echo $bestTotal; ?> total hits[[/strong]]
    (earliest winning rank [[strong]]<?php echo htmlspecialchars($bestRankText, ENT_QUOTES); ?>[[/strong]]).
  [[/div]]

  [[div style="font-size:0.9rem; margin-bottom:0.4rem; color:#34495e; line-height:1.45;"]]
    <?php echo htmlspecialchars($advice, ENT_QUOTES); ?>
  [[/div]]

  [[div style="font-size:0.85rem; color:#4a5568; line-height:1.4;"]]
    [[strong]]Per-method pattern:[[/strong]]
    [[em]]<?php echo htmlspecialchars(implode('  •  ', $perMethodSummaries), ENT_QUOTES); ?>[[/em]]
    [[br]]
    [[span style="opacity:0.9;"]]
      Tip: Aim to stack more of your chosen numbers where methods hit early (ranks #1–#5), and use later ranks as light support numbers.
    [[/span]]
  [[/div]]
[[/div]]

[[/div]]

      <!-- ============ COMMON ACROSS (world-class agreement bar) ============ -->
      [[div class="prediction-card common-card"
            data-common-bar
            data-has-extra="<?php
              // Use lottery_skip_config.json (keyed by gameId) as the canonical source.
              $gid = (string) ($g['game_id'] ?? '');
              $hasExtra = 0;
              $mainMax  = 0;
              $extraMax = 0;
              $extraCnt = 0;

              $cfgFile = JPATH_ROOT . '/lottery_skip_config.json';
              if (is_file($cfgFile)) {
                $cfg = json_decode((string) file_get_contents($cfgFile), true);
                if (json_last_error() === JSON_ERROR_NONE && !empty($cfg['lotteries'][$gid]['lotteryConfig'])) {
                  $lc = $cfg['lotteries'][$gid]['lotteryConfig'];

                  $mainMax  = (int) ($lc['max_main_ball_number'] ?? 0);
                  $hasExtra = !empty($lc['has_extra_ball']) ? 1 : 0;
                  $extraMax = (int) ($lc['max_extra_ball_number'] ?? 0);

                  // Supports games with 2 extras (e.g., EuroMillions)
                  $extraCnt = (int) ($lc['num_extra_balls_drawn'] ?? 0);
                  if ($extraCnt < 0) { $extraCnt = 0; }
                }
              }

              echo $hasExtra ? '1' : '0';
            ?>"
            data-main-max="<?php echo (int) ($mainMax ?? 0); ?>"
            data-extra-max="<?php echo (int) ($extraMax ?? 0); ?>"
            data-extra-count="<?php echo (int) ($extraCnt ?? 0); ?>"
      ]]
        [[div class="card-header" style="display:flex; align-items:center; gap:0.75rem; flex-wrap:wrap; justify-content:flex-start;"]]
          [[div style="display:flex; flex-direction:column; gap:0.15rem;"]]
            [[div style="display:flex; align-items:baseline; gap:0.5rem; flex-wrap:wrap;"]]
              [[strong style="font-size:1.1rem; color:#1f2a3a; letter-spacing:0.01em;" data-common-title]]
                Numbers in Common
              [[/strong]]
              [[span class="common-count" style="font-weight:600; font-size:0.95rem; color:#1f618d;"]]
                (Mains: 0, Extra: 0, Total: 0)
              [[/span]]
            [[/div]]
            [[div style="font-size:0.9rem; color:#576574; max-width:42rem; line-height:1.4;" data-common-desc]]
              Numbers that appear across multiple selected methods. When methods agree, the signal is stronger.
            [[/div]]
          [[/div]]
        [[/div]]

        [[div class="common-numbers"
              style="padding:0.85rem 1rem 1rem; display:flex; flex-wrap:wrap; gap:0.5rem; border-top:1px solid #e3e7ef;"]]
          <!-- JS will inject overlaps here -->
        [[/div]]

        <!-- ===== Decision Set — Your Final Pick (click-to-build) ===== -->
        [[div data-decision-wrap style="padding:0 1rem 0.85rem; border-top:1px dashed #e3e7ef;"]]
          [[div style="display:flex; align-items:flex-start; justify-content:space-between; gap:0.75rem; flex-wrap:wrap; padding-top:0.75rem;"]]
            [[div]]
              [[div style="font-weight:800; color:#0A1A33; letter-spacing:0.01em;"]]
                Your Selection
              [[/div]]
[[div data-decision-help style="font-size:0.9rem; color:#576574; line-height:1.45; max-width:48rem;"]]
  Click numbers to build your pool. Select as many as you want, then save or use for wheeling combinations.
[[/div]]
            [[/div]]

            [[div data-decision-status style="font-size:0.9rem; font-weight:700; color:#1f618d;"]]
              Selected: 0 mains • 0 <?php echo htmlspecialchars($extraLabel ?? 'extra', ENT_QUOTES); ?>
            [[/div]]
          [[/div]]

          [[div data-decision-grid
                style="margin-top:0.65rem; display:grid; gap:0.65rem;"]]
            <!-- JS injects mains/extras pick grid here -->
          [[/div]]

          [[div style="margin-top:0.65rem; display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;"]]
            [[button type="button" class="btn-secondary" data-decision-clear
                     style="padding:0.4rem 0.8rem; font-size:0.85rem;"]]
              Clear selection
            [[/button]]

            [[button type="button" class="btn-primary" data-decision-autofill
                     style="padding:0.4rem 0.8rem; font-size:0.85rem;"]]
              Auto-fill from top agreement
            [[/button]]

            [[button type="button" class="btn-secondary" data-decision-toggle-grid
                     style="padding:0.4rem 0.8rem; font-size:0.85rem;"]]
              Add more numbers
            [[/button]]

            [[span data-decision-ready style="font-size:0.85rem; color:#6b7280; font-weight:600;"]]
              Select numbers to build your wheel pool.
            [[/span]]
          [[/div]]

          <!-- Manual pool builder: number grid -->
          [[div data-decision-grid-panel
                style="display:none; margin-top:0.75rem; padding:0.85rem; border:1px solid #e3e7ef; border-radius:12px; background:linear-gradient(180deg, #EFEFF5 0%, #FFFFFF 100%);"]]

            [[div style="display:flex; align-items:flex-start; justify-content:space-between; gap:0.75rem; flex-wrap:wrap;"]]
              [[div style="font-weight:800; color:#0A1A33;"]]
                Add numbers to your pool
              [[/div]]
              [[div style="font-size:0.9rem; color:#576574; max-width:46rem; line-height:1.45;"]]
                Tap to toggle. Selected numbers stay highlighted in your Decision Set.
              [[/div]]
            [[/div]]

            [[div style="margin-top:0.65rem; display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;"]]
              [[input type="search" data-decision-search
                       placeholder="Search number…"
                       style="width:180px; max-width:100%; padding:0.45rem 0.6rem; border-radius:10px; border:1px solid #dbe4f0; font-weight:600;"]]
              [[span style="font-size:0.85rem; color:#6b7280; font-weight:600;"]]
                Tip: use this to jump to a number quickly.
              [[/span]]
            [[/div]]

            [[div data-decision-number-grids style="margin-top:0.75rem; display:grid; gap:0.75rem;"]]
              <!-- JS injects mains/extras grids here -->
            [[/div]]
          [[/div]]
        [[/div]]
        <!-- ===== /Decision Set ===== -->

        <!-- REMOVED: Field Coverage section
             Reason: Redundant and not useful.
             This section and its associated calculations have been removed entirely.
             Original location: lines ~3488-3495
        -->

        [[div style="padding:0 1rem 0.85rem; border-top:1px dashed #e3e7ef; margin-top:0.15rem; font-size:0.78rem; color:#4b5563; display:flex; flex-wrap:wrap; gap:0.5rem 0.75rem; align-items:center;"]]
          [[span style="font-weight:600; text-transform:uppercase; letter-spacing:0.04em; font-size:0.75rem; color:#6b7280;"]]
            Number Tags:
          [[/span]]
          [[span class="btag btag-hit"]]HIT[[/span]]
          [[span style="font-size:0.75rem;"]]Matched actual draw[[/span]]

          [[span class="btag btag-ovl"]]OVL[[/span]]
          [[span style="font-size:0.75rem;"]]Appears in 2+ methods[[/span]]

          [[span class="btag btag-ai"]]NN[[/span]]
          [[span style="font-size:0.75rem;"]]Neural network[[/span]]

          [[span class="btag btag-sh"]]PA[[/span]]
          [[span style="font-size:0.75rem;"]]Pattern analysis[[/span]]

          [[span class="btag btag-mm"]]PS[[/span]]
          [[span style="font-size:0.75rem;"]]Probability sampling[[/span]]

          [[span class="btag btag-hm"]]FM[[/span]]
          [[span style="font-size:0.75rem;"]]Frequency map[[/span]]
        [[/div]]
      [[/div]]

      <!-- Narrative: What Stands Out -->
      [[div class="narrative-header" style="margin:1.5rem 1rem 1rem; padding:1rem; background:linear-gradient(135deg, #f8fafc 0%, #e7f3ff 100%); border-left:3px solid #3b82f6; border-radius:8px;"]]
        [[h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600; color:#1e40af;"]]
          What to Look For
        [[/h3]]
        [[p style="margin:0; font-size:0.95rem; line-height:1.6; color:#334155;"]]
          Compare predictions across methods below. Numbers that appear in multiple methods are agreement signals. Where methods diverge shows the range of possibilities. Use the comparison tools to find common numbers.
        [[/p]]
      [[/div]]

      <!-- ── Three‐column layout: Skip & Hit | AI | MCMC ── -->
      [[div class="predictions-row"]]

        <?php
          // 1) Group saved runs by source
          $predsBySource = [];
          foreach ($g['preds'] as $s) {
            $predsBySource[$s->source][] = $s;
          }
        ?>

        <?php foreach ($modules as $mod):
          $moduleKey     = $mod['key'];
          $moduleLabel   = $mod['label'];
          $moduleIcon    = $mod['icon'];
          $moduleTooltip = $mod['tooltip'] ?? '';
          $runs          = $predsBySource[$moduleKey] ?? [];
        ?>
        [[div class="prediction-column"]]

          <?php if (!empty($runs)): ?>

            <?php foreach ($runs as $s):
              $ts       = $s->generated_at ?: $s->date_saved;
              $draw     = getDrawByDate($g['game_id'], $g['draw_date'], $db);
                            $fields     = getDrawFields($g['game_id']);
              $mainCols   = $fields['main']  ?? [];
              $extraCol   = $fields['extra'] ?? null;

              // Game-aware label for the extra ball (falls back to "Extra Ball")
              $extraLabel = 'Extra Ball';
              if (!empty($configData['lotteries'][$g['game_id']]['lotteryConfig']['extra_ball_label'])) {
                  $extraLabel = (string) $configData['lotteries'][$g['game_id']]['lotteryConfig']['extra_ball_label'];
              } else {
                  // Heuristics by game name (optional fallback)
                  $lname = strtolower((string) ($g['lottery_name'] ?? ''));
                  if (strpos($lname, 'powerball') !== false)      $extraLabel = 'Powerball';
                  elseif (strpos($lname, 'mega') !== false)       $extraLabel = 'Mega Ball';
                  elseif (strpos($lname, 'lucky star') !== false) $extraLabel = 'Lucky Star';
                  elseif (strpos($lname, 'star') !== false)       $extraLabel = 'Star';
                  elseif (strpos($lname, 'bonus') !== false)      $extraLabel = 'Bonus Ball';
              }

              // Build normalized lists: mains in $drawMain, extras in $drawExtra (array for future multi-extras)
              $drawMain  = [];
              $drawExtra = [];
              if ($draw) {
                foreach ($mainCols as $col) {
                  if (isset($draw[$col]) && $draw[$col] !== '') {
                    $drawMain[] = (int) $draw[$col];
                  }
                }
                if ($extraCol && isset($draw[$extraCol]) && $draw[$extraCol] !== '') {
                  $drawExtra[] = (int) $draw[$extraCol];
                }
              }

            ?>

            [[div class="prediction-card <?php echo str_replace('_','-',$s->source); ?>"
     data-set-id="<?php echo (int)$s->id; ?>"
     data-source="<?php echo htmlspecialchars($s->source, ENT_QUOTES); ?>"
     data-pure="<?php echo ($s->source==='skip_hit' && (int)($s->pure_mode ?? 0)===1) ? '1' : '0'; ?>"]]


[[div class="card-header"]]
  [[div class="header-left"]]
    [[div class="header-badges"]]
       [[span class="source-badge" title="<?php echo htmlspecialchars($moduleTooltip, ENT_QUOTES); ?>"]]
        <?php
          // Only show the icon if it is non-empty, then show the label
          if (!empty($moduleIcon)) {
              echo $moduleIcon . ' ';
          }
          echo htmlspecialchars($moduleLabel, ENT_QUOTES);
        ?>
      [[/span]]

      <?php
        // Default: use the stored label
        $displayLabel = '';
        if (!empty($s->label)) {
            $displayLabel = (string) $s->label;
        }

        // For hybrid model (SKAI), build a consistent label
        if ($s->source === 'skai_prediction') {
            // Resolve a lottery name just like our header logic
            $lotName = '';
            if (!empty($g['lottery_name'])) {
                $lotName = $g['lottery_name'];
            } elseif (!empty($g['game_name'])) {
                $lotName = $g['game_name'];
            } elseif (!empty($s->lottery_name)) {
                $lotName = $s->lottery_name;
            }

            // Pick a timestamp: generated_at → date_saved → draw_date
            $tsRaw = $s->generated_at ?: ($s->date_saved ?: ($g['draw_date'] ?? ''));
            $ts    = strtotime((string) $tsRaw);
            // Output ISO 8601 format for JavaScript to convert to local timezone
            $when  = $ts ? date('c', $ts) : (string) $tsRaw;

            if ($lotName !== '') {
                $displayLabel = $lotName . ' Hybrid Analysis';
            } else {
                $displayLabel = 'Hybrid Analysis';
            }
        }

        if ($displayLabel !== ''):
      ?>
        [[span class="timestamp-label" style="font-size:0.85rem; color:#333; font-weight:600;" data-timestamp="<?php echo htmlspecialchars($when, ENT_QUOTES); ?>"]]
          <?php echo htmlspecialchars($displayLabel, ENT_QUOTES); ?> – [[span class="local-time"]]<?php echo htmlspecialchars($when, ENT_QUOTES); ?>[[/span]]
        [[/span]]
      <?php endif; ?>

    [[/div]]
    
    <?php
  // Show PURE-SKIP badge only for Skip & Hit that were saved with pure_mode=1
  $isPure = (isset($s->pure_mode) && (int)$s->pure_mode === 1);
  if ($s->source === 'skip_hit' && $isPure):
?>
  [[span class="badge pure-badge" title="Generated with Pure Skip mode"]]
    PURE-SKIP
  [[/span]]

  <?php if (!empty($s->pure_uid)): ?>
    [[span class="badge gray" title="Unique identifier for this PURE run"]]
      ID: <?php echo htmlspecialchars(substr((string)$s->pure_uid, 0, 8), ENT_QUOTES); ?>
    [[/span]]
  <?php endif; ?>
<?php endif; ?>

    [[label class="header-compare"]]
      [[input
        type="checkbox"
        class="card-compare-checkbox"
        value="<?php echo (int)$s->id; ?>"
        aria-label="Compare <?php echo htmlspecialchars($moduleLabel, ENT_QUOTES); ?> prediction for <?php echo htmlspecialchars($g['lottery_name'] ?? '', ENT_QUOTES); ?>"
      ]]
      Compare
    [[/label]]
  [[/div]]

[[button
  class="settings-toggle"
  type="button"
  title="Show details"
  aria-expanded="false"
  aria-controls="settings-panel-<?php echo (int)$s->id; ?>"
]]
  Details
[[/button]]

[[/div]]
              <?php if ($draw): ?>
                [[div]]Drawn:
                  <?php foreach ($mainCols as $col): if (isset($draw[$col]) && $draw[$col] !== ''): ?>
                    [[span class="drawn-pill"]]
                      <?php echo htmlspecialchars($draw[$col], ENT_QUOTES); ?>
                    [[/span]]
                  <?php endif; endforeach; ?>
                [[/div]]

                <?php if ($extraCol && isset($draw[$extraCol]) && $draw[$extraCol] !== ''): ?>
                  [[div]]<?php echo htmlspecialchars($extraLabel, ENT_QUOTES); ?>:
                    [[span class="drawn-pill extra"]]
                      <?php echo htmlspecialchars($draw[$extraCol], ENT_QUOTES); ?>
                    [[/span]]
                  [[/div]]
                <?php endif; ?>

              <?php else: ?>
                [[div]]Drawn: [[em]]Upcoming[[/em]][[/div]]
              <?php endif; ?>

              [[div]]Your Numbers:
                <?php
                  // Normalize predicted main numbers to ints
                  $predMain = array_slice(
                    array_map('intval', explode(',', (string)$s->main_numbers)),
                    0,
                    20
                  );
                                    foreach ($predMain as $n):
                    $isHit = in_array($n, $drawMain, true);
                    $cls   = $isHit ? 'match-pill' : 'no-match';

                ?>
                  [[span class="<?php echo $cls; ?>"]]
                    <?php echo $n; ?>
                  [[/span]]
                <?php endforeach; ?>
              [[/div]]

                            <?php if (!empty($s->extra_ball_numbers)): ?>
                [[div]]<?php echo htmlspecialchars($extraLabel, ENT_QUOTES); ?>:
                  <?php
                    $predExtra = array_slice(
                      array_map('intval', explode(',', (string)$s->extra_ball_numbers)),
                      0,
                      5
                    );
                    foreach ($predExtra as $e):
                      $isHit = in_array($e, $drawExtra, true); // compare only against extra(s)
                      $cls   = $isHit ? 'match-pill extra' : 'no-match extra';
                  ?>
                    [[span class="<?php echo $cls; ?>"]]
                      <?php echo $e; ?>
                    [[/span]]
                  <?php endforeach; ?>
                [[/div]]
              <?php endif; ?>

[[div
  id="settings-panel-<?php echo (int)$s->id; ?>"
  class="settings-panel"
  role="region"
  aria-label="Saved settings for <?php echo htmlspecialchars($moduleLabel, ENT_QUOTES); ?> prediction for <?php echo htmlspecialchars($g['lottery_name'] ?? '', ENT_QUOTES); ?>"
  style="margin-top:auto; font-size:.75rem; line-height:1.4; color:#444; padding-top:0.5rem;"
  aria-hidden="true"
]]

<?php
  // normalize your source just in case
  $src = trim((string)$s->source);

  // pick the labels you want
  $settingLabels = [];
  if ($src === 'ai_prediction') {
    $settingLabels = [
      'epochs'              => 'Epochs',
      'batch_size'          => 'Batch',
      'dropout_rate'        => 'Dropout',
      'learning_rate'       => 'LR',
      'activation_function' => 'ActFn',
      'hidden_layers'       => 'Layers',
      'recency_decay'       => 'Recency Decay',
    ];
  } elseif ($src === 'skai_prediction') {
    $settingLabels = [
      // Core neural hyperparameters
      'epochs'              => 'Epochs',
      'batch_size'          => 'Batch',
      'dropout_rate'        => 'Dropout',
      'learning_rate'       => 'Learning rate',
      'activation_function' => 'Activation',
      'hidden_layers'       => 'Hidden layers',
      'recency_decay'       => 'Recency decay',
      // Windows
      'skai_window_size'    => 'SKAI window',
      'skip_window'         => 'Skip window',
      'draws_used'          => 'Draws used',
      'tuned_window'        => 'Tuned window',
      // Behavior & sampling
      'sampling_temperature'=> 'Sampling temp',
      'diversity_penalty'   => 'Diversity penalty',
      'gap_scale'           => 'Gap scale',
      // Mode / automation
      'skai_run_mode'       => 'Run mode',
      'auto_tune'           => 'Auto-tune',
      'tune_used'           => 'Tune used',
      'best_window'         => 'Best window',
      // Output size
      'skai_top_n_numbers'  => 'Top N numbers',
      'skai_top_n_combos'   => 'Top N combos',
    ];
} elseif ($src === 'mcmc_prediction') {
    $settingLabels = [
      'walks'     => 'Walks',
      'burn_in'   => 'Burn-in',
      'laplace_k' => 'Laplace K',
      'decay'     => 'Decay',
      'chain_len' => 'Chain Len',
    ];
} elseif ($src === 'skip_hit') {
    $settingLabels = [
      'draws_analyzed' => 'Draws',
      'freq_weight'    => 'Freq Wt',
      'skip_weight'    => 'Skip Wt',
      'hist_weight'    => 'Hist Wt',
      // pseudo-field we’ll render manually just below:
      // 'pure_mode'   => 'Pure Mode',
    ];
}
 elseif ($src === 'heatmap') {
    // Heatmap saves just numbers + label; no expert settings.
    $settingLabels = [];
}

  // timestamp (safe against invalid dates) - output ISO format for JS conversion
  $__ts = strtotime((string)($s->date_saved ?? ''));
  $__tsStr = $__ts ? date('c', $__ts) : (string)($s->date_saved ?? '');
  echo '[[div style="margin-bottom: .3rem;" class="timestamp-container" data-timestamp="' . htmlspecialchars($__tsStr, ENT_QUOTES) . '"]][[em class="local-time"]]'
     . htmlspecialchars($__tsStr, ENT_QUOTES)
     . '[[/em]][[/div]]';

// now render the grid
if (!empty($settingLabels)) {
  echo '[[div class="settings-grid"]]';

  // Prefer JSON settings payload when present (prevents “Epochs = 0” when values are saved in JSON).
  $rawSettingsJson = null;
  foreach (['settings_json','settings','params_json','params'] as $__k) {
    if (isset($s->$__k) && $s->$__k !== null && $s->$__k !== '') {
      $rawSettingsJson = (string)$s->$__k;
      break;
    }
  }
  $decodedSettings = [];
  if ($rawSettingsJson) {
    $decodedSettings = json_decode($rawSettingsJson, true);
    if (!is_array($decodedSettings)) $decodedSettings = [];
  }

  foreach ($settingLabels as $prop => $settingLabel) {
    $val = $s->$prop ?? null;

    // If the DB column is empty/0 but JSON has a real value, use JSON.
    if (($val === null || $val === '' || $val === 0 || $val === '0') && array_key_exists($prop, $decodedSettings)) {
      $val = $decodedSettings[$prop];
    }

    if ($val !== null && $val !== '') {
      echo '[[div class="setting-row"]]'
         . '[[strong]]' . htmlspecialchars($settingLabel, ENT_QUOTES) . ':[[/strong]] '
         . htmlspecialchars((string)$val, ENT_QUOTES)
         . '[[/div]]';
    }
  }

  // SKAI “mode” (Profile / Strategy / Blend) — show if present in JSON
  if ($src === 'skai_prediction') {
    $profile  = $decodedSettings['profile']  ?? ($decodedSettings['training_style'] ?? null);
    $strategy = $decodedSettings['strategy'] ?? null;
    $blend    = $decodedSettings['blend']    ?? ($decodedSettings['blend_percent'] ?? null);

    if ($profile || $strategy || $blend !== null) {
      echo '[[div class="setting-row"]]'
         . '[[strong]]Training style:[[/strong]] '
         . htmlspecialchars((string)($profile ?: '—'), ENT_QUOTES)
         . '[[/div]]';

      echo '[[div class="setting-row"]]'
         . '[[strong]]Skip vs AI strategy:[[/strong]] '
         . htmlspecialchars((string)($strategy ?: '—'), ENT_QUOTES)
         . '[[/div]]';

      echo '[[div class="setting-row"]]'
         . '[[strong]]Blend:[[/strong]] '
         . htmlspecialchars((string)($blend !== null ? $blend : '—'), ENT_QUOTES)
         . '[[/div]]';
    }
  }

  // Append Pure Mode details for Skip & Hit runs
  if ($src === 'skip_hit') {
    $pureMode = (int)($s->pure_mode ?? 0);
    echo '[[div class="setting-row"]]'
       . '[[strong]]Pure Mode:[[/strong]] '
       . ($pureMode === 1 ? 'Yes' : 'No')
       . '[[/div]]';
  }

  // Append a human-friendly blend summary for SKAI runs
  if ($src === 'skai_prediction') {
    $blendSkip = isset($s->skai_blend_skip_pct) ? (float) $s->skai_blend_skip_pct : null;
    $blendAi   = isset($s->skai_blend_ai_pct)   ? (float) $s->skai_blend_ai_pct   : null;

    if ($blendSkip !== null || $blendAi !== null) {
        if ($blendSkip !== null && $blendAi === null) {
            $blendAi = max(0.0, min(100.0, 100.0 - $blendSkip));
        }

        if ($blendSkip !== null) {
            $blendSkip = round($blendSkip, 1);
        }

        if ($blendAi !== null) {
            $blendAi = round($blendAi, 1);
        }

        $blendValue = '';
        if ($blendSkip !== null && $blendAi !== null) {
            $blendValue = $blendSkip . '% Skip / ' . $blendAi . '% AI';
        } elseif ($blendSkip !== null) {
            $blendValue = $blendSkip . '% Skip';
        } elseif ($blendAi !== null) {
            $blendValue = $blendAi . '% AI';
        }

        if ($blendValue !== '') {
            echo '[[div class="setting-row"]]'
               . '[[strong]]Blend:[[/strong]] '
               . htmlspecialchars($blendValue, ENT_QUOTES)
               . '[[/div]]';
        }
    }
  }

  echo '[[/div]]';
} else {
    echo '[[em]]No advanced settings were saved for this run.[[/em]]';
}

?>

[[/div]]

<?php
  // inside the foreach where $g (and $s) are in scope (safe against invalid dates):
  $__dts = strtotime((string)($g['draw_date'] ?? ''));
  $prettyDate = $__dts ? date('M j, Y', $__dts) : (string)($g['draw_date'] ?? '');
  $defaultName = htmlspecialchars(
    (string)$g['lottery_name'] . ' – ' . $prettyDate,
    ENT_QUOTES
  );

?>
[[form method="post" style="margin-top:0.75rem;"]]
  <?php echo \Joomla\CMS\HTML\HTMLHelper::_('form.token'); ?>
  [[input type="hidden" name="save_setting_template" value="1"]]
  [[input type="hidden" name="source"              value="<?php echo $s->source; ?>"]]
  [[input type="hidden" name="lottery_id"          value="<?php echo (int)$s->lottery_id; ?>"]]

<?php foreach (array_keys($settingLabels) as $prop): ?>
   <?php if (isset($s->$prop) && $s->$prop !== '' && $s->$prop !== null): ?>
     [[input type="hidden" name="<?php echo $prop; ?>"
               value="<?php echo htmlspecialchars((string)$s->$prop, ENT_QUOTES); ?>"]]
   <?php endif; ?>
 <?php endforeach; ?>

  <!-- here we prefill the template name -->
  [[input type="text"
          name="setting_name"
          value="<?php echo $defaultName; ?>"
          placeholder="Save as template…"
          style="width:100%; padding:6px; margin-bottom:6px; font-size:.9rem;"]]

  [[button type="submit" class="btn-primary"
           style="padding:0.3rem 0.8rem; font-size:.8rem;"]]
    💾 Save Settings
  [[/button]]
[[/form]]

[[form method="post" style="margin-top:.5rem;" onsubmit="return confirm('Delete this saved prediction?');"]]
  <?php echo \Joomla\CMS\HTML\HTMLHelper::_('form.token'); ?>

  [[input type="hidden" name="delete_set"
             value="<?php echo (int)$s->id; ?>"]]
  [[button type="submit" class="btn-danger"]]Delete[[/button]]
[[/form]]
[[/div]]  <!-- end .prediction-card -->
                
 <?php endforeach; ?>

 <?php else: ?>

  [[div class="prediction-card prediction-placeholder"]]

    [[div class="prediction-placeholder-title"
           style="font-size:1rem; font-weight:600; color:#2c3e50; text-align:center; margin-bottom:0.5rem;"]]
      No <?php echo htmlspecialchars($moduleLabel, ENT_QUOTES); ?> predictions yet
    [[/div]]

    [[div style="text-align:center; font-size:0.95rem; color:#444; line-height:1.5; margin-bottom:1rem; padding:0 0.5rem;"]]
      Run this analysis to fill this column. After you save a prediction, it will appear here with the matching draw so you can review how your picks performed.
    [[/div]]

    [[div style="text-align:center; margin-top:auto;"]]
      <?php if (!empty($lottoUrl)): ?>
[[a href="<?php echo htmlspecialchars($lottoUrl, ENT_QUOTES); ?>"
             target="_blank"
             rel="noopener"
             class="btn-primary btn-insight"]]
  ▶️ ▶️ Run <?php echo htmlspecialchars($moduleLabel, ENT_QUOTES); ?> Prediction
[[/a]]

      <?php else: ?>
        [[button type="button" class="btn-primary btn-insight" disabled]]
          ▶️ ▶️ Run <?php echo htmlspecialchars($moduleLabel, ENT_QUOTES); ?> Prediction
        [[/button]]
      <?php endif; ?>
    [[/div]]

  [[/div]]

<?php endif; ?>

          [[/div]]  <!-- end .prediction-column -->

        <?php endforeach; ?>
      [[/div]]  <!-- end .predictions-row -->
      
    [[/div]]  <!-- end .lottery-collapsible-content -->
    [[/div]]  <!-- end .lottery-group -->
  <?php endforeach; ?>

<?php endif; ?>
[[/div]]  <!-- end .prediction-panel -->

<?php
// Load user’s saved settings templates
$q = $db->getQuery(true)
    ->select([
        's.*',
        'l.name AS lottery_name',
        'st.name AS state_name'
    ])
    ->from($db->quoteName('#__user_saved_settings', 's'))
    ->join('LEFT', $db->quoteName('#__lotteries', 'l') . ' ON s.lottery_id = l.lottery_id')
    ->join('LEFT', $db->quoteName('#__states', 'st') . ' ON l.state_id = st.state_id')
    ->where('s.user_id = ' . (int) $user->id)
    ->order('s.created_at DESC');

$db->setQuery($q);
$savedSettings = $db->loadAssocList() ?: [];

?>
<?php if (!empty($savedSettings)): ?>
  [[div class="card" style="margin-top:2rem;"]]
    [[div class="card-header"]]
      [[h3 class="title"]]Saved Configurations[[/h3]]
      [[p style="margin:0; color:var(--skai-text-secondary); font-size:0.9rem;"]]Reuse your tested settings for future predictions[[/p]]
    [[/div]]
    [[ul style="list-style:none; margin:0; padding:1rem;"]]
      <?php foreach ($savedSettings as $set):
        // Decode JSON params
        $params = json_decode($set['params'], true) ?: [];
      ?>
        [[li style="margin-bottom:1.5rem;"]]
          [[strong]]<?php echo htmlspecialchars($set['setting_name'], ENT_QUOTES); ?>[[/strong]] —
          <?php
            // Source label + location
            $sourceLabel = ucfirst(str_replace('_', ' ', $set['source']));
            $state       = htmlspecialchars($set['state_name'] ?? 'Unknown', ENT_QUOTES);
            $lotteryName = htmlspecialchars($set['lottery_name'] ?? 'Unknown', ENT_QUOTES);
            echo "$sourceLabel for $state • $lotteryName";
          ?>
          [[br]]
          [[em]]<?php echo date('M j, Y g:ia', strtotime($set['created_at'])); ?>[[/em]]

          <?php if ($params): ?>
            [[div class="settings-params" style="font-size:0.85rem; color:#333; margin-top:0.5rem;"]]
              <?php
                // human‑friendly labels
                $labels = [
                  'draws_analyzed'      => 'Draws',
                  'freq_weight'         => 'Freq Wt',
                  'skip_weight'         => 'Skip Wt',
                  'hist_weight'         => 'Hist Wt',
                  'epochs'              => 'Epochs',
                  'batch_size'          => 'Batch',
                  'dropout_rate'        => 'Dropout',
                  'learning_rate'       => 'LR',
                  'activation_function' => 'ActFn',
                  'hidden_layers'       => 'Layers',
                  'walks'               => 'Walks',
                  'burn_in'             => 'Burn‑in',
                  'laplace_k'           => 'Laplace K',
                  'decay'               => 'Decay',
                  'chain_len'           => 'Chain Len',
                ];
                $parts = [];
                foreach ($params as $key => $val) {
                  $lbl = $labels[$key] ?? ucwords(str_replace('_',' ',$key));
                  $parts[] = htmlspecialchars($lbl, ENT_QUOTES) . ': ' . htmlspecialchars($val, ENT_QUOTES);
                }
                echo implode(' | ', $parts);
              ?>
            [[/div]]
          <?php endif; ?>

[[form method="post" style="margin-top:0.5rem;" onsubmit="return confirm('Delete this saved settings template?');"]]
  <?php echo \Joomla\CMS\HTML\HTMLHelper::_('form.token'); ?>

  [[input type="hidden" name="delete_setting_template" value="<?php echo (int)$set['id']; ?>"]]
  [[button type="submit" class="btn-danger" style="font-size:0.75rem; padding:0.3rem 0.8rem;"]]
    🗑️ Delete
  [[/button]]
[[/form]]

        [[/li]]
      <?php endforeach; ?>
    [[/ul]]
  [[/div]]
<?php endif; ?>


[[script]]

document.addEventListener('DOMContentLoaded', () => {
  const S = (window.S && typeof window.S === 'function')
  ? window.S
  : (str => String(str).replace(/\[\[/g, '<').replace(/\]\]/g, '>'));

// =============================
// SKAI Living Engine (v1)
// - per-lottery memory (localStorage, bounded)
// - simple trends + posture + next steps
// =============================
var __SKAI_LIVE_V__ = 1;
var __SKAI_LIVE_NS__ = 'skai_live_v' + __SKAI_LIVE_V__ + '_';

function skaiSafeJsonParse(str, fallback){
  try { return JSON.parse(str); } catch(e){ return fallback; }
}
function skaiSafeJsonStringify(obj, fallback){
  try { return JSON.stringify(obj); } catch(e){ return fallback || '[]'; }
}
function skaiLiveKey(lotteryId){
  return __SKAI_LIVE_NS__ + 'lottery_' + String(lotteryId || 'unknown');
}
function skaiLiveAppend(lotteryId, entry, maxKeep){
  maxKeep = (typeof maxKeep === 'number' && maxKeep > 3) ? maxKeep : 12;

  var key = skaiLiveKey(lotteryId);
  var arr = [];
  try {
    arr = skaiSafeJsonParse(localStorage.getItem(key) || '[]', []);
    if (!Array.isArray(arr)) arr = [];
  } catch(e){
    arr = [];
  }

  arr.push(entry);
  if (arr.length > maxKeep) arr = arr.slice(arr.length - maxKeep);

  try { localStorage.setItem(key, skaiSafeJsonStringify(arr, '[]')); } catch(e){}
  return arr;
}
function skaiLiveRead(lotteryId){
  var key = skaiLiveKey(lotteryId);
  try {
    var arr = skaiSafeJsonParse(localStorage.getItem(key) || '[]', []);
    return Array.isArray(arr) ? arr : [];
  } catch(e){
    return [];
  }
}
function skaiTrendSentence(arr, field, label){
  label = label || 'Signal';
  if (!arr || arr.length < 3) return '';

  var last3 = arr.slice(-3);
  var a = Number(last3[0] && last3[0][field]);
  var b = Number(last3[1] && last3[1][field]);
  var c = Number(last3[2] && last3[2][field]);
  if (!isFinite(a) || !isFinite(b) || !isFinite(c)) return '';

  var delta = c - a;
  if (delta >= 2) return label + ' is rising over the last 3 runs.';
  if (delta <= -2) return label + ' is weakening over the last 3 runs.';

  var vol = Math.abs(b - a) + Math.abs(c - b);
  if (vol >= 4) return label + ' has been volatile recently.';
  return label + ' has been relatively steady.';
}
function skaiConfidenceTrend(arr){
  if (!arr || arr.length < 3) return '';
  var map = { 'Single-method':0, 'Exploratory':1, 'Balanced':2, 'High':3 };
  var last3 = arr.slice(-3).map(function(x){
    var k = (x && x.levelLabel) ? x.levelLabel : 'Exploratory';
    return map[k] || 0;
  });
  var a = last3[0], b = last3[1], c = last3[2];
  var delta = c - a;

  if (delta >= 2) return 'Confidence posture is improving across recent runs.';
  if (delta <= -2) return 'Confidence posture has softened across recent runs.';
  if (Math.abs((b - a)) + Math.abs((c - b)) >= 3) return 'Confidence posture has been inconsistent recently.';
  return 'Confidence posture has been stable recently.';
}
function skaiPosture(levelLabel, methodsUsed, overlapScore, evidenceScore){
  methodsUsed = Number(methodsUsed) || 0;
  overlapScore = Number(overlapScore) || 0;
  evidenceScore = Number(evidenceScore) || 0;

  if (methodsUsed <= 1 || levelLabel === 'Single-method') {
    return 'Signal quality is limited because only one method is active — useful for exploration, but not for agreement.';
  }
  if (levelLabel === 'High') {
    return 'Signal quality looks consistent — multiple methods are pointing in similar directions.';
  }
  if (levelLabel === 'Balanced') {
    return 'Signal quality is workable — some agreement exists, with normal uncertainty.';
  }
  if (overlapScore === 0 && evidenceScore === 0) {
    return 'Signal quality is early-stage — treat this run as learning-focused and keep building history.';
  }
  return 'Signal quality is exploratory — good for learning patterns, not for precision.';
}
function skaiNextSteps(levelLabel, checkedLen, methodsUsed, overlapScore, evidenceScore){
  var steps = [];

  checkedLen    = Number(checkedLen) || 0;
  methodsUsed   = Number(methodsUsed) || 0;
  overlapScore  = Number(overlapScore) || 0;
  evidenceScore = Number(evidenceScore) || 0;

  if (checkedLen === 1) {
    steps.push('Add one more method so you can measure agreement (not just one viewpoint).');
    steps.push('Try “Compare All” once — it helps you see where methods overlap.');
    return steps;
  }

  // Multi-method but no overlap: likely different assumptions/settings
  if (methodsUsed >= 2 && overlapScore === 0) {
    steps.push('Your selected methods disagree right now. That’s useful — it means you’re seeing different viewpoints.');
    steps.push('Try adjusting one setting at a time (draw window, epochs/walks, or smoothing), then save a new run.');
    steps.push('Aim for at least 1–2 overlaps before treating anything as a “core” set.');
    return steps;
  }

  // Some overlap: suggest strengthening evidence
  if (methodsUsed >= 2 && overlapScore > 0 && evidenceScore === 0) {
    steps.push('You have some agreement. Next: build evidence by saving a few more runs so trends can appear.');
    steps.push('Mix in a few mid-rank numbers (#4–#10) from each method so you’re not all-in on #1 picks.');
    return steps;
  }

  // Higher quality: suggest stability and iteration discipline
  if (levelLabel === 'High' || levelLabel === 'Balanced') {
    steps.push('This is a reasonable baseline. Keep your core stable and iterate slowly (one setting change per run).');
    steps.push('After the next draw, use “post” mode to see which ranks actually hit and tune toward those ranges.');
    return steps;
  }

  return steps;
}

// Reset learning (delegated) — clears localStorage keys for this lottery
document.addEventListener('click', function(ev){
  var el = ev.target;
  if (!el) return;

  // Allow clicks on nested nodes (e.g., strong/span) inside the link
  var link = el.closest ? el.closest('[data-skai-reset-learning]') : null;
  if (!link) return;

  ev.preventDefault();

  var lotteryId = link.getAttribute('data-lottery-id') || '';
  if (!lotteryId) return;

  var ok = confirm('Reset learning history for this lottery? This clears trend memory used by the living analysis.');
  if (!ok) return;

  try {
    // Remove known learning namespaces (safe no-ops if they do not exist)
    var prefixes = ['skai_live_', 'skai_learning_', 'skai_learn_', 'skai_mem_'];
    for (var i = localStorage.length - 1; i >= 0; i--) {
      var k = localStorage.key(i);
      if (!k) continue;

      // Only keys that contain this lotteryId and match one of our prefixes
      var hasPrefix = false;
      for (var p = 0; p < prefixes.length; p++) {
        if (k.indexOf(prefixes[p]) === 0) { hasPrefix = true; break; }
      }
      if (!hasPrefix) continue;

      if (k.indexOf(lotteryId) !== -1) {
        localStorage.removeItem(k);
      }
    }
  } catch(e){}

  // Refresh this group: dispatch events on first checkbox
  try {
    var group = document.querySelector('.lottery-group[data-lottery-id="' + lotteryId + '"]');
    if (group) {
      var first = group.querySelector('.card-compare-checkbox');
      if (first) {
        ['input','change'].forEach(function(type){
          first.dispatchEvent(new Event(type, { bubbles:true, cancelable:true }));
        });
      }
    }
  } catch(e){}
});

Array.prototype.forEach.call(document.querySelectorAll('.lottery-group'), function(group) {

    var compareBoxes = group.querySelectorAll('.card-compare-checkbox');
    var commonCard   = group.querySelector('.prediction-card.common-card[data-common-bar]');
    var numbersDiv   = commonCard ? commonCard.querySelector('.common-numbers') : null;
    var cards        = group.querySelectorAll('.prediction-card');

// Auto-select exactly ONE compare box per method (first/earliest card only)
(function autoSelectOnePerMethod(){
  const chosen = Object.create(null); // method -> true
  const boxes = group.querySelectorAll('.prediction-card .card-compare-checkbox');

  boxes.forEach(cb => {
    const card   = cb.closest('.prediction-card');
    const method = card ? String(card.getAttribute('data-source')||'').trim() : '';
    if (!chosen[method]) {
      cb.checked = true;      // first time we see this method => select it
      chosen[method] = true;
    } else {
      cb.checked = false;     // all other runs for same method => leave off
    }
  });

  // Fire change once to ensure the narrative & overlaps render
  const first = boxes[0];
  if (first) {
    ['input','change'].forEach(type =>
      first.dispatchEvent(new Event(type, { bubbles:true, cancelable:true }))
    );
  }
})();

// Wire up updates on selection changes and render once initially
compareBoxes.forEach(cb => cb.addEventListener('change', update));
update();

        function update() {
      // Narrative target + mode
      const narrativeEl = group.querySelector('[data-narrative]');
      const modeHolder  = group.querySelector('.narrative-card');
      const mode = modeHolder ? String(modeHolder.getAttribute('data-mode')||'pre') : 'pre';

      const checked = Array.from(compareBoxes).filter(cb => cb.checked);

      // IMPORTANT: allow 1+ selected methods (single method = “Selected method numbers” mode)
      if (!commonCard || !numbersDiv || checked.length < 1) {
        commonCard && (commonCard.style.display = 'none');
        return;
      }

      // Show the bar for both 1-method and multi-method (title/desc will adapt later)
      commonCard && (commonCard.style.display = 'block');

  // Table header
  var html = '';
  html += '<table>';
  html += '<thead><tr>';
  html += '<th style="text-align:left;">Method</th>';
  for (var c = 1; c <= maxMain; c++) html += '<th>' + c + '</th>';
  html += '<th>Row Total</th>';
  html += '</tr></thead>';
  html += '<tbody>';

  var methodOrder = ['skip_hit','ai_prediction','mcmc_prediction','skai_prediction','heatmap'];
  methodOrder.forEach(function(m){
    // Only render methods that actually exist in selStats
    if (!selStats[m] || !selStats[m].main) return;

    var rowTotal = 0;
    html += '<tr>';
    html += '<td style="text-align:left; font-weight:800;">' + (labelShort[m] || m) + '</td>';

    for (var r = 1; r <= maxMain; r++) {
      var v = (selStats[m].main[r] || 0);
      rowTotal += v;

      // Simple, readable intensity (keeps UI fast).
      var cls = (v === 0) ? 'zero' : 'nonzero';
      html += '<td class="' + cls + '" title="Hits at rank #' + r + ': ' + v + '">' + v + '</td>';
    }

    html += '<td style="font-weight:800;">' + rowTotal + '</td>';
    html += '</tr>';
  });

  html += '</tbody></table>';
  host.innerHTML = html;
}

        function update() {

      // Narrative target + mode
      const narrativeEl = group.querySelector('[data-narrative]');
      const modeHolder  = group.querySelector('.narrative-card');
      const mode = modeHolder ? String(modeHolder.getAttribute('data-mode') || 'pre') : 'pre';

var checked = Array.prototype.filter.call(compareBoxes, function(cb){ return !!cb.checked; });

// Brand-honest behavior:
// - 0 selected: hide the bar and stop.
// - 1 selected: show “Selected method numbers” (single-run view).
// - 2+ selected: show “Common Agreement Bar” (true overlap view).
if (!commonCard || !numbersDiv) {
  return;
}

if (checked.length < 1) {
  commonCard.style.display = 'none';

  // FIX: Clear all highlights when no cards are selected
  Array.prototype.forEach.call(cards, function(card){
    var nodes = card.querySelectorAll('.match-pill, .no-match');
    Array.prototype.forEach.call(nodes, function(el){
      el.classList.remove('common-highlight','drawn-match');
    });
  });

  // Clear the numbers display
  if (numbersDiv) {
    numbersDiv.innerHTML = '';
  }
  return;
}

      // Keep visible for 1+ selections; we will rename title/desc later based on count.
      commonCard.style.display = 'block';

// Get arrays of MAIN and EXTRA numbers separately from each selected card
function toInt(s){
  var n = parseInt(String(s).trim(), 10);
  return isFinite(n) ? n : null;
}

// Per-card sets
var setsMain = [];
var setsExtra = [];

Array.prototype.forEach.call(checked, function(cb){
  var card = cb.closest ? cb.closest('.prediction-card') : null;
  if (!card) { setsMain.push([]); setsExtra.push([]); return; }

  // MAIN
  var mainNodes = card.querySelectorAll('.match-pill:not(.extra), .no-match:not(.extra)');
  var mains = [];
  Array.prototype.forEach.call(mainNodes, function(el){
    var v = toInt(el.textContent);
    if (v !== null) mains.push(v);
  });
  setsMain.push(mains);

  // EXTRA
  var extraNodes = card.querySelectorAll('.match-pill.extra, .no-match.extra');
  var extras = [];
  Array.prototype.forEach.call(extraNodes, function(el){
    var v = toInt(el.textContent);
    if (v !== null) extras.push(v);
  });
  setsExtra.push(extras);
});

// Intersections & agreement levels
// - commonsMain / commonsExtra  = strict overlap (present in EVERY selected card)
// - softMain / softExtra        = soft overlap   (present in 2+ selected cards)
// NOTE: when only ONE method is selected, “commons” should be that full method list (so Auto-fill grabs ALL).
var commonsMain  = [];
var commonsExtra = [];
var softMain     = [];
var softExtra    = [];

      if (setsMain.length) {
        if (setsMain.length === 1) {
          // Single-method mode: treat the full list as the “common” set
          commonsMain = Array.from(new Set(setsMain[0].slice()));
          softMain    = Array.from(new Set(setsMain[0].slice()));
        } else {
          commonsMain = setsMain.reduce(function(a, b){
            return a.filter(function(v){ return b.indexOf(v) !== -1; });
          });
        }
      }
      if (setsExtra.length) {
        if (setsExtra.length === 1) {
          // Single-method mode: treat the full list as the “common” set
          commonsExtra = Array.from(new Set(setsExtra[0].slice()));
          softExtra    = Array.from(new Set(setsExtra[0].slice()));
        } else {
          commonsExtra = setsExtra.reduce(function(a, b){
            return a.filter(function(v){ return b.indexOf(v) !== -1; });
          });
        }
      }

      // Single selection = NOT an “agreement”.
      // Show the selected method’s numbers as a helpful, action-ready view.
      if (checked.length === 1) {
        commonsMain  = (setsMain.length  ? setsMain[0].slice()  : []);
        commonsExtra = (setsExtra.length ? setsExtra[0].slice() : []);
      }

      // Soft agreement: at least 2 “voices” across the selected cards
      function freqMapFromLists(lists){
        const freq = Object.create(null);
        lists.forEach(function(list){
          const seen = Object.create(null);
          list.forEach(function(n){
            const key = String(n);
            if (seen[key]) { return; } // don’t double-count within the same card
            seen[key] = true;
            freq[key] = (freq[key] || 0) + 1;
          });
        });
        return freq;
      }

      if (setsMain.length >= 2) {
        const fmMain = freqMapFromLists(setsMain);
        softMain = Object.keys(fmMain)
          .map(function(k){ return parseInt(k, 10); })
          .filter(function(n){ return fmMain[String(n)] >= 2; });
      }
      if (setsExtra.length >= 2) {
        const fmExtra = freqMapFromLists(setsExtra);
        softExtra = Object.keys(fmExtra)
          .map(function(k){ return parseInt(k, 10); })
          .filter(function(n){ return fmExtra[String(n)] >= 2; });
      }

      // Ensure each number only appears once: remove strict hits from the soft lists
      if (commonsMain.length && softMain.length) {
        const strictMainMap = Object.create(null);
        commonsMain.forEach(function(n){ strictMainMap[String(n)] = true; });
        softMain = softMain.filter(function(n){ return !strictMainMap[String(n)]; });
      }
      if (commonsExtra.length && softExtra.length) {
        const strictExtraMap = Object.create(null);
        commonsExtra.forEach(function(n){ strictExtraMap[String(n)] = true; });
        softExtra = softExtra.filter(function(n){ return !strictExtraMap[String(n)]; });
      }

      // Display in probability order (numbers already ordered by prediction method)
      // DO NOT sort numerically - preserve the order from predictions (highest probability first)
      // Tiebreaker: when equal frequency across methods, natural prediction order is maintained
      // commonsMain, softMain, commonsExtra, softExtra are kept in their natural order

// Drawn mains vs extras (pull from the FIRST prediction card if possible)
function uniqueOrdered(nums){
  const seen = new Set(), out = [];
  nums.forEach(n => { if (!seen.has(n)) { seen.add(n); out.push(n); } });
  return out;
}
function drawnFromFirstCard(){
  const firstDrawn = group.querySelector('.prediction-card .drawn-pill');
  const firstCard  = firstDrawn ? firstDrawn.closest('.prediction-card') : null;
  if (!firstCard) return { m: [], e: [] };

  const m = Array.from(firstCard.querySelectorAll('.drawn-pill:not(.extra)'))
    .map(el => toInt(el.textContent)).filter(n => n !== null);
  const e = Array.from(firstCard.querySelectorAll('.drawn-pill.extra'))
    .map(el => toInt(el.textContent)).filter(n => n !== null);
  return { m: uniqueOrdered(m), e: uniqueOrdered(e) };
}

let { m: drawnMain, e: drawnExtra } = drawnFromFirstCard();
if (!drawnMain.length) {
  drawnMain = uniqueOrdered(
    Array.from(group.querySelectorAll('.drawn-pill:not(.extra)'))
      .map(el => toInt(el.textContent)).filter(n => n !== null)
  );
  drawnExtra = uniqueOrdered(
    Array.from(group.querySelectorAll('.drawn-pill.extra'))
      .map(el => toInt(el.textContent)).filter(n => n !== null)
  );
}
      // Build separate sections for mains and extras
      // Now uses BALL styles so it matches the legend:
      // - ball-hit  = HIT (matched the actual draw)
      // - ball-ovl  = OVL (shows up in more than one method)
      function renderPill(n, isDrawn, isExtra) {
        // Clickable pill: feeds Decision Set.
        // NOTE: no backticks; Sorcerer-safe output.
        var cls = isDrawn
          ? (isExtra ? 'drawn-pill extra' : 'drawn-pill')
          : 'common-highlight';

        // Add a stable hook + data for selection.
        // data-role="pick" keeps delegation simple and fast.
        return '[[span class="' + cls + ' le-pick-pill" data-role="pick" data-num="' + n + '" data-extra="' + (isExtra ? '1' : '0') + '" tabindex="0" role="button" aria-pressed="false"]]' +
                 n +
               '[[/span]]';
      }

      // Strict overlap: everyone agrees
      const strictMainHTML = commonsMain.length
        ? commonsMain.map(function(n){ return renderPill(n, drawnMain.includes(n), false); }).join('')
        : '[[em]]No numbers appear in every selected method yet.[[/em]]';

      const strictExtraHTML = (commonsExtra.length || drawnExtra.length)
        ? (
            commonsExtra.length
              ? commonsExtra.map(function(n){ return renderPill(n, drawnExtra.includes(n), true); }).join('')
              : '[[em]]No extras appear in every selected method yet.[[/em]]'
          )
        : '';

      // Soft overlap: used by 2+ selected methods
      const softMainHTML = softMain.length
        ? softMain.map(function(n){ return renderPill(n, drawnMain.includes(n), false); }).join('')
        : '[[em]]No soft overlaps yet (numbers used by 2+ selected methods).[[/em]]';

      const softExtraHTML = softExtra.length
        ? softExtra.map(function(n){ return renderPill(n, drawnExtra.includes(n), true); }).join('')
        : '[[em]]No soft extra overlaps yet.[[/em]]';

// Brand-honest labels based on selection count
var h1 = (checked.length === 1) ? 'Selected method numbers:' : 'Everyone agrees (strict):';
var d1 = (checked.length === 1)
  ? 'Numbers from the single method you selected. Add another method to see true agreement.'
  : 'Numbers that all selected methods share.';

var h2 = (checked.length === 1) ? 'Agreement signals (requires 2+ methods):' : 'Most methods agree (soft, 2+ voices):';
var d2 = (checked.length === 1)
  ? 'Soft agreement appears when at least two selected methods share a number.'
  : 'Good secondary candidates that show up in more than one selected method.';

// In single-selection mode, make soft sections a calm instructional message
var softMainBody  = (checked.length === 1) ? '[[em]]Select at least two methods to see soft overlaps.[[/em]]' : softMainHTML;
var softExtraBody = (checked.length === 1) ? '[[em]]Select at least two methods to see soft overlaps.[[/em]]' : softExtraHTML;

numbersDiv.innerHTML =
  S('[[div class="section-h"]]' + h1 + '[[/div]]') +
  S('[[div class="s-row subtle"]]' + d1 + '[[/div]]') +
  S('[[div style="margin:.25rem 0 0.5rem;"]]' + strictMainHTML + '[[/div]]') +
  (
    (commonsExtra.length || drawnExtra.length)
      ? S('[[div style="margin:.15rem 0 0.4rem;"]][[strong]]' + (window.extraLabel || 'Extras') + ':[[/strong]] ' + strictExtraHTML + '[[/div]]')
      : ''
  ) +
  S('[[div class="narrative-divider"]][[/div]]') +
  S('[[div class="section-h"]]' + h2 + '[[/div]]') +
  S('[[div class="s-row subtle"]]' + d2 + '[[/div]]') +
  S('[[div style="margin:.25rem 0 0.5rem;"]]' + softMainBody + '[[/div]]') +
  (
    (softExtra.length || drawnExtra.length)
      ? S('[[div style="margin:.15rem 0 0.4rem;"]][[strong]]' + (window.extraLabel || 'Extras') + ':[[/strong]] ' + softExtraBody + '[[/div]]')
      : ''
  );

      // ─────────────────────────────────────────────────────────
      // Decision Set (click-to-build) — selection state per group
      // ─────────────────────────────────────────────────────────
      var decisionWrap   = group.querySelector('[data-decision-wrap]');
      var decisionGrid   = group.querySelector('[data-decision-grid]');
      var decisionStatus = group.querySelector('[data-decision-status]');
      var decisionHelp   = group.querySelector('[data-decision-help]');
      var btnClear       = group.querySelector('[data-decision-clear]');
      var btnAutofill    = group.querySelector('[data-decision-autofill]');
      var btnToggleGrid  = group.querySelector('[data-decision-toggle-grid]');
      var gridPanel      = group.querySelector('[data-decision-grid-panel]');
      var gridHost       = group.querySelector('[data-decision-number-grids]');
      var gridSearch     = group.querySelector('[data-decision-search]');
      var decisionReady  = group.querySelector('[data-decision-ready]');

      // Baseline ticket sizes (guidance only — Decision Set is a wheel pool builder).
      // If drawn is present, its length is the most truthful pick size for this lottery.
      var reqMain  = (drawnMain && drawnMain.length) ? drawnMain.length : 5;
      var reqExtra = (drawnExtra && drawnExtra.length) ? drawnExtra.length : 0;

      // state: store as Sets on the group element to persist through update() calls
      if (!group.__decisionState) {
        group.__decisionState = { main: new Set(), extra: new Set() };
      }

      function normNum(n){
        var v = parseInt(String(n).trim(), 10);
        return Number.isFinite(v) ? v : null;
      }

      function renderDecisionGridUI(){
        if (!decisionWrap || !decisionGrid) return;

        var st = group.__decisionState;
        // Display in probability order - DO NOT sort numerically
        // Numbers are kept in the order they were selected (typically probability order from predictions)
        var mains = Array.from(st.main);
        var extras = Array.from(st.extra);

        // Status line (brand-simple): show total selected only
        if (decisionStatus) {
          var parts = [];
          parts.push('Selected mains: ' + st.main.size);

          var hasExtrasCfg = (commonCard && String(commonCard.getAttribute('data-has-extra') || '0') === '1');
          if (hasExtrasCfg) {
            parts.push((window.extraLabel || 'Extras') + ' selected: ' + st.extra.size);
          }

          decisionStatus.textContent = parts.join(' • ');
        }

        // Guidance state (never blocking): show when the pool is viable for a ticket and/or good for wheeling.
        var meetsTicket = (mains.length >= reqMain) && (reqExtra === 0 || extras.length >= reqExtra);

        if (decisionReady) {
          var msg = '';

          if (mains.length === 0 && (reqExtra === 0 || extras.length === 0)) {
            msg = 'Start by clicking numbers above. Build a pool for wheeling or for a single ticket.';
          } else if (meetsTicket) {
            msg = 'Ready — this pool can generate tickets. Add more numbers if you are building a larger wheel.';
          } else {
            msg = 'In progress — for a standard ticket you typically need at least ' + reqMain + ' mains' +
                  (reqExtra ? (' and at least ' + reqExtra + ' ' + (window.extraLabel || 'extra') + (reqExtra === 1 ? '' : 's')) : '') +
                  '. You can still keep building a larger wheel pool.';
          }

          decisionReady.textContent = msg;
        }

        // Build a calm, grid-aligned display
        var html = '';

        html += '[[div style="display:grid; gap:0.35rem; padding:0.75rem; border:1px solid #e3e7ef; border-radius:12px; background:linear-gradient(180deg, #EFEFF5 0%, #FFFFFF 100%);"]]' +
                  '[[div style="font-weight:800; color:#0A1A33;"]]Mains selected: ' + mains.length + '[[/div]]' +
                  '[[div class="chips" style="gap:0.4rem;"]]';

        if (mains.length) {
          mains.forEach(function(n){
            html += '[[span class="common-highlight le-pick-selected" data-role="pick-selected" data-num="' + n + '" data-extra="0" tabindex="0" role="button" aria-label="Remove main ' + n + '"]]' + n + '[[/span]]';
          });
        } else {
          html += '[[span style="color:#6b7280; font-weight:600; font-size:0.9rem;"]]No mains selected yet.[[/span]]';
        }

        html += '[[/div]][[/div]]';

        // Show extras when:
        // - config says the lottery has extras (data-has-extra="1"), OR
        // - extras exist in the UI already, OR
        // - the user has selected extras.
        var hasExtrasCfg = false;
        if (commonCard && commonCard.getAttribute) {
          hasExtrasCfg = (String(commonCard.getAttribute('data-has-extra') || '0') === '1');
        }

        var hasExtrasUI = !!group.querySelector('.match-pill.extra, .no-match.extra, .drawn-pill.extra');
        var showExtras  = hasExtrasCfg || hasExtrasUI || (extras.length > 0);

        if (showExtras) {
          html += '[[div style="display:grid; gap:0.35rem; padding:0.75rem; border:1px solid #e3e7ef; border-radius:12px; background:#fff;"]]' +
                    '[[div style="font-weight:800; color:#0A1A33;"]]' + (window.extraLabel || 'Extra') + ' selected: ' + extras.length + '[[/div]]' +
                    '[[div class="chips" style="gap:0.4rem;"]]';

          if (extras.length) {
            extras.forEach(function(n){
              html += '[[span class="common-highlight le-pick-selected" data-role="pick-selected" data-num="' + n + '" data-extra="1" tabindex="0" role="button" aria-label="Remove extra ' + n + '"]]' + n + '[[/span]]';
            });
          } else {
            html += '[[span style="color:#6b7280; font-weight:600; font-size:0.9rem;"]]No extras selected yet.[[/span]]';
          }

          html += '[[/div]][[/div]]';
        }

        decisionGrid.innerHTML = S(html);

        // Update pill pressed state in the agreement area for clarity
        group.querySelectorAll('.le-pick-pill[data-role="pick"]').forEach(function(p){
          var n = normNum(p.getAttribute('data-num'));
          var isExtra = (String(p.getAttribute('data-extra')) === '1');
          var selected = isExtra ? st.extra.has(n) : st.main.has(n);

          p.setAttribute('aria-pressed', selected ? 'true' : 'false');
          if (selected) {
            p.classList.add('le-is-selected');
          } else {
            p.classList.remove('le-is-selected');
          }
        });
      }

      function togglePick(n, isExtra){
        var st = group.__decisionState;
        var v = normNum(n);
        if (v === null) return;

        // Pool builder: no hard caps.
        if (isExtra) {
          if (st.extra.has(v)) st.extra.delete(v);
          else st.extra.add(v);
        } else {
          if (st.main.has(v)) st.main.delete(v);
          else st.main.add(v);
        }

        renderDecisionGridUI();
      }

      function clearDecision(){
        if (!group.__decisionState) return;
        group.__decisionState.main.clear();
        group.__decisionState.extra.clear();
        renderDecisionGridUI();
      }

      function autofillFromAgreement(){
        clearDecision();

        // Auto-fill = pull ALL agreement signals into the wheel pool (strict + soft).
        var st = group.__decisionState;

        function addAll(list, isExtra){
          if (!list || !list.length) return;
          for (var i=0; i<list.length; i++){
            var v = normNum(list[i]);
            if (v === null) continue;

            if (isExtra) st.extra.add(v);
            else st.main.add(v);
          }
        }

        // Strict overlaps (everyone agrees)
        addAll(commonsMain, false);
        addAll(commonsExtra, true);

        // Soft overlaps (2+ voices)
        addAll(softMain, false);
        addAll(softExtra, true);

        renderDecisionGridUI();
        renderDecisionNumberGrids(); // keep grids in sync if panel is open
      }

      // Build the manual “Add numbers” grids (pool builder)
      function getGridMaxes(){
        // Preferred: use config values stamped on commonCard; fallback to safe defaults.
        var mainMax = 69;
        var extraMax = 26;

        if (commonCard && commonCard.getAttribute) {
          var mm = parseInt(String(commonCard.getAttribute('data-main-max') || ''), 10);
          var em = parseInt(String(commonCard.getAttribute('data-extra-max') || ''), 10);
          if (Number.isFinite(mm) && mm > 0) mainMax = mm;
          if (Number.isFinite(em) && em > 0) extraMax = em;
        }

        return { mainMax: mainMax, extraMax: extraMax };
      }

      function buildGrid(title, max, isExtra, filterVal){
        var st = group.__decisionState;
        var html = '';
        html += '[[div style="padding:0.75rem; border:1px solid #e3e7ef; border-radius:12px; background:#fff;"]]' +
                  '[[div style="display:flex; align-items:baseline; justify-content:space-between; gap:0.75rem; flex-wrap:wrap;"]]' +
                    '[[div style="font-weight:800; color:#0A1A33;"]]' + title + '[[/div]]' +
                    '[[div style="font-size:0.85rem; color:#6b7280; font-weight:700;"]]' +
                      'Tap to toggle • Selected stays highlighted' +
                    '[[/div]]' +
                  '[[/div]]' +
                  '[[div style="margin-top:0.6rem; display:grid; grid-template-columns:repeat(auto-fill, minmax(44px, 1fr)); gap:0.45rem;"]]';

        for (var n=1; n<=max; n++){
          // Search filter (optional)
          if (filterVal !== null && filterVal !== '' && String(n).indexOf(String(filterVal)) === -1) continue;

          var selected = isExtra ? st.extra.has(n) : st.main.has(n);

          // Grid pills: DO NOT use "common-highlight" as the base class.
          // common-highlight is reserved for agreement/overlap visuals elsewhere.
          var cls = selected ? 'le-pick-pill le-is-selected' : 'le-pick-pill';

          html += '[[span class="' + cls + '" data-role="grid-pick" data-num="' + n + '" data-extra="' + (isExtra ? '1' : '0') + '" tabindex="0" role="button" aria-pressed="' + (selected ? 'true' : 'false') + '"]]' +
                    n +
                  '[[/span]]';
        }

        html += '[[/div]][[/div]]';
        return html;
      }

      function renderDecisionNumberGrids(){
        if (!gridHost) return;
        if (!gridPanel || gridPanel.style.display === 'none') return;

        var mx = getGridMaxes();
        var filterVal = (gridSearch && gridSearch.value)
          ? String(gridSearch.value).replace(/[^\d]/g, '')
          : '';

        var html = '';
        html += buildGrid('Main number pool', mx.mainMax, false, filterVal);

        // Extras: driven by config (data-extra-count), not by DOM presence.
        var hasExtrasCfg = (commonCard && String(commonCard.getAttribute('data-has-extra') || '0') === '1');
        var extraCount = 0;
        if (commonCard && commonCard.getAttribute) {
          extraCount = parseInt(String(commonCard.getAttribute('data-extra-count') || '0'), 10);
          if (!Number.isFinite(extraCount) || extraCount < 0) extraCount = 0;
        }

        // If config indicates extras exist, always render the extras pool grid.
        if (hasExtrasCfg && extraCount >= 1) {
          var label = (window.extraLabel || 'Extra');

          // Single extras pool (Powerball/Mega/etc)
          if (extraCount === 1) {
            html += buildGrid(label + ' number pool', mx.extraMax, true, filterVal);
          } else {
            // Multi-extra games (EuroMillions etc): same pool range, but label clearly.
            for (var k = 1; k <= extraCount; k++) {
              html += buildGrid(label + ' ' + k + ' number pool', mx.extraMax, true, filterVal);
            }
          }
        }

        gridHost.innerHTML = S(html);
      }

      function toggleGridPick(num, isExtra){
        togglePick(num, isExtra);     // uses your existing toggle logic (no caps)
        renderDecisionNumberGrids();  // keep grid buttons in sync
      }

      // Bind click handlers once per group/commonCard
      if (!group.__decisionBound) {
        group.__decisionBound = true;

        // Click/keyboard on pills in the agreement area
        commonCard.addEventListener('click', function(ev){
          var t = ev.target;
          if (!t || !t.getAttribute) return;

          var role = t.getAttribute('data-role');
          if (role === 'pick') {
            ev.preventDefault();
            togglePick(t.getAttribute('data-num'), String(t.getAttribute('data-extra')) === '1');
          } else if (role === 'pick-selected') {
            ev.preventDefault();
            togglePick(t.getAttribute('data-num'), String(t.getAttribute('data-extra')) === '1');
          }
        });

        commonCard.addEventListener('keydown', function(ev){
          var t = ev.target;
          if (!t || !t.getAttribute) return;

          var role = t.getAttribute('data-role');
          if (role !== 'pick' && role !== 'pick-selected') return;

          if (ev.key === 'Enter' || ev.key === ' ') {
            ev.preventDefault();
            togglePick(t.getAttribute('data-num'), String(t.getAttribute('data-extra')) === '1');
          }
        });

        if (btnClear) btnClear.addEventListener('click', function(){
          clearDecision();
          renderDecisionNumberGrids();
        });

        if (btnAutofill) btnAutofill.addEventListener('click', function(){
          autofillFromAgreement();
        });

        if (btnToggleGrid && gridPanel) {
          btnToggleGrid.addEventListener('click', function(){
            var open = (gridPanel.style.display !== 'none');
            gridPanel.style.display = open ? 'none' : 'block';
            if (!open) renderDecisionNumberGrids();
          });
        }

        if (gridSearch) {
          gridSearch.addEventListener('input', function(){
            renderDecisionNumberGrids();
          });
        }

        // Click/keyboard inside the manual grids
        if (gridPanel) {
          gridPanel.addEventListener('click', function(ev){
            var t = ev.target;
            if (!t || !t.getAttribute) return;
            if (t.getAttribute('data-role') !== 'grid-pick') return;

            ev.preventDefault();
            toggleGridPick(t.getAttribute('data-num'), String(t.getAttribute('data-extra')) === '1');
          });

          gridPanel.addEventListener('keydown', function(ev){
            var t = ev.target;
            if (!t || !t.getAttribute) return;
            if (t.getAttribute('data-role') !== 'grid-pick') return;

            if (ev.key === 'Enter' || ev.key === ' ') {
              ev.preventDefault();
              toggleGridPick(t.getAttribute('data-num'), String(t.getAttribute('data-extra')) === '1');
            }
          });
        }
      }

      // Render now (each update)
      renderDecisionGridUI();
      renderDecisionNumberGrids();


      // Update title/description depending on whether we have true agreement
      const titleEl = commonCard.querySelector('[data-common-title]');
      const descEl  = commonCard.querySelector('[data-common-desc]');

      if (checked.length === 1) {
        if (titleEl) titleEl.textContent = 'Selected method numbers';
        if (descEl)  descEl.textContent  = 'Numbers from one method. Select another method to see where they agree.';
      } else {
        if (titleEl) titleEl.textContent = 'Numbers in Common';
        if (descEl)  descEl.textContent  = 'Numbers that appear across multiple selected methods. When methods agree, the signal is stronger.';
      }

      // Update count (Mains + Extras)
      const countSpan = commonCard.querySelector('.common-count');
      if (countSpan) {
        const total = commonsMain.length + commonsExtra.length;
countSpan.textContent = '(Mains: ' + commonsMain.length + ', Extra: ' + commonsExtra.length + ', Total: ' + total + ')';
      }

      commonCard.style.display = 'block';

      // FIX C: Proper deselection behavior - Clear old highlights, then re-apply
      // Step 1: Clear ALL highlights from ALL cards (checked + unchecked)
      // This ensures numbers from deselected cards are no longer bold
      cards.forEach(card =>
        card.querySelectorAll('.match-pill, .no-match')
            .forEach(el => el.classList.remove('common-highlight','drawn-match'))
      );

      // Step 2: Re-apply highlights ONLY for numbers that appear in CHECKED cards' overlap lists
      // Highlight overlaps on the prediction cards:
      // - Strict overlaps (commons*) AND soft overlaps (soft*) should be highlighted,
      //   since users interpret “in common” as “shared by 2+ methods”, not only “shared by all”.
      function applyOverlapHighlight(list, isExtra) {
        if (!list || !list.length) { return; }

        list.forEach(function(num){
          checked.forEach(function(cb){
            var card = cb.closest('.prediction-card');
            if (!card) { return; }

            var selector = isExtra
              ? '.match-pill.extra, .no-match.extra'
              : '.match-pill:not(.extra), .no-match:not(.extra)';

            card.querySelectorAll(selector).forEach(function(el){
              var v = Number(String(el.textContent || '').trim());
              if (v !== num) { return; }

              // If it matched the actual draw, prioritize the HIT styling.
              if (isExtra ? drawnExtra.includes(num) : drawnMain.includes(num)) {
                el.classList.add('drawn-match');
              } else {
                el.classList.add('common-highlight');
              }
            });
          });
        });
      }

      // Strict overlaps (everyone agrees)
      applyOverlapHighlight(commonsMain, false);
      applyOverlapHighlight(commonsExtra, true);

      // Soft overlaps (2+ voices) — this is what was missing
      applyOverlapHighlight(softMain, false);
      applyOverlapHighlight(softExtra, true);

      // ─────────────────────────────────────────────────────────
      // Dynamic Narrative based on CURRENT selection (mode-aware)
      // ─────────────────────────────────────────────────────────
      // IMPORTANT: Decision Strip updates must run even if narrative is not present.
      // So we run this block when either narrative OR decision strip exists.
      if (narrativeEl || group.querySelector('[data-decision-strip]')) {
        // Build per-method placement histograms for the selection only
        var methods = ['skip_hit','ai_prediction','mcmc_prediction','skai_prediction','heatmap'];
var labelShort = {
          skip_hit:        'Skip & Hit',
          ai_prediction:   'AI',
          mcmc_prediction: 'MCMC',
          skai_prediction: 'SKAI',
          heatmap:         'Heatmap'
        };
        var maxMain = 20;
        var maxExtra = 5;

        // initialize placement counters
        var selStats = {};
        var selectedCountsByMethod = {};
methods.forEach(function(m){
          selStats[m] = { main: {}, extra: {}, mainTotal:0, extraTotal:0, runs:0 };
          for (var i=1;i<=maxMain;i++){ selStats[m].main[i] = 0; }
          for (var j=1;j<=maxExtra;j++){ selStats[m].extra[j] = 0; }
          selectedCountsByMethod[m] = 0;
        });

// Track selection size for rendering decisions (used by renderSelectionHeatmap)
selStats.__selectedCount = checked.length;



         // helper: list rank positions from pill order (robust, de-dupes, normalizes "01" -> 1)
        function getPositions(card, selector, limit){
          var pos = Object.create(null);     // number -> 1-based rank
          if (!card) return pos;

          var nodes = card.querySelectorAll(selector);
          var seen  = Object.create(null);   // track first occurrence per number

          for (var i = 0; i < nodes.length && i < limit; i++) {
            var raw = String(nodes[i].textContent || '').trim();
            // keep only digits; normalize leading zeros (e.g., "01" -> "1")
            var clean = raw.replace(/[^\d]/g, '');
            if (clean === '') continue;
            // normalize to integer
            var n = parseInt(clean, 10);
            if (!Number.isFinite(n)) continue;

            // keep FIRST position only
            if (seen[n]) continue;
            seen[n] = true;

            // 1-based rank
            pos[n] = i + 1;
          }
          return pos;
        }

        // Compute placement stats for SELECTED cards
        checked.forEach(function(cb){
          var card = cb.closest('.prediction-card');
          var method = card ? String(card.getAttribute('data-source') || '').trim() : '';
          if (methods.indexOf(method) === -1) { method = 'skip_hit'; }

          selectedCountsByMethod[method] += 1;
          selStats[method].runs += 1;

          // Order in DOM = prediction rank order, which is what we want
          var posMain  = getPositions(card, '.match-pill:not(.extra), .no-match:not(.extra)', maxMain);
          var posExtra = getPositions(card, '.match-pill.extra, .no-match.extra', maxExtra);

          // Compare predicted ranks vs actual drawn mains
          for (var di = 0; di < drawnMain.length; di++) {
            var hit = drawnMain[di];
            var r = posMain[hit];
            if (r && r >= 1 && r <= maxMain) {
              selStats[method].main[r] += 1;
              selStats[method].mainTotal += 1;
            }
          }

          // Compare predicted ranks vs actual extras
          for (var ei = 0; ei < drawnExtra.length; ei++) {
            var eh = drawnExtra[ei];
            var re = posExtra[eh];
            if (re && re >= 1 && re <= maxExtra) {
              selStats[method].extra[re] += 1;
              selStats[method].extraTotal += 1;
            }
          }
        });


         // Build sweet-spot sentences for selected methods only (mains)
        // - Computes top 2 rank "peaks" per method in the CURRENT selection
        // - Produces readable sentences with proper pluralization
        // (deduped) Helpers declared below:
        // sumObjectVals, plural, fmtRankList, topRanksWithTies


          // Build sweet-spot sentences for selected methods only (mains)
        // - Handles ties (up to 3 ranks), nice English, and % of hits at peaks
        function sumObjectVals(obj){
          var s = 0; for (var k in obj){ if (Object.prototype.hasOwnProperty.call(obj,k)) s += obj[k]; }
          return s;
        }
        function plural(n, one, many){ return (n===1?one:many); }
        function fmtRankList(ranks){
          // ranks: array of integers -> "#4", "#7" & "#9"
          var tags = ranks.map(function(r){ return '#' + r; });
          if (tags.length === 0) return '';
          if (tags.length === 1) return tags[0];
          if (tags.length === 2) return tags[0] + ' & ' + tags[1];
          return tags.slice(0, tags.length-1).join(', ') + ' & ' + tags[tags.length-1];
        }
function topRanksWithTies(row, maxShow, minTotal){
  // Sweet spot = ranks with the highest hit counts among selected cards,
  // only if we have enough evidence (≥ minTotal total hits).
  var total = 0, maxVal = 0, ranks = [];
  for (var k in row){
    if (!Object.prototype.hasOwnProperty.call(row,k)) continue;
    var v = row[k]|0;
    total += v;
    if (v > maxVal) maxVal = v;
  }
  if (total < (minTotal|0) || maxVal <= 0) return { ranks: [], peakTotal: 0, maxVal: 0, total: total };
  for (var k2 in row){
    if (!Object.prototype.hasOwnProperty.call(row,k2)) continue;
    if ((row[k2]|0) === maxVal) ranks.push(parseInt(k2,10));
  }
  ranks.sort(function(a,b){ return a - b; });
  var shown = ranks.slice(0, Math.max(1, maxShow|0));
  var peakTotal = shown.reduce(function(acc, r){ return acc + (row[r]|0); }, 0);
  return { ranks: shown, peakTotal: peakTotal, maxVal: maxVal, total: total };
}


        var bits = [];  // e.g., ["AI peaks near #4 & #7"]
        methods.forEach(function(m){
          var row   = selStats[m].main || {};
          var total = sumObjectVals(row);
          if (total > 0){
            var peak = topRanksWithTies(row, 3, 3);           // show up to 3 tied peaks
            if (peak.ranks.length){
              var msg = labelShort[m] + ' peaks near ' + fmtRankList(peak.ranks);
              bits.push(msg);
            }
          }
        });

        // Overlap quick summary (selection-aware)
        var overlapParts = [];
        if (checked.length >= 2) {
          if (commonsMain.length) { overlapParts.push(commonsMain.length + ' ' + plural(commonsMain.length,'main overlap','main overlaps')); }
          if (commonsExtra.length){ overlapParts.push(commonsExtra.length + ' ' + plural(commonsExtra.length,'extra overlap','extra overlaps')); }
        }
        var overlapLine = overlapParts.length ? (' Overlap across selected: ' + overlapParts.join(' + ') + '.') : '';

// ---------- Narrative helpers (structured recommendations + recap) ----------
function unique(arr){ return Array.from(new Set(arr)); }
function take(arr, n){ return arr.slice(0, Math.max(0,n|0)); }
function freqMap(nums){ var m=Object.create(null); nums.forEach(n=>m[n]=(m[n]|0)+1); return m; }
function topByFreq(mapObj, limit, excludeSet){
  var rows = [];
  for (var k in mapObj){
    if (!Object.prototype.hasOwnProperty.call(mapObj,k)) continue;
    var v = parseInt(k,10);
    if (excludeSet && excludeSet.has(v)) continue;
    rows.push({v:v, c:mapObj[k]|0});
  }
  rows.sort(function(a,b){ return (b.c - a.c) || (a.v - b.v); });
  return rows.slice(0, Math.max(0,limit|0)).map(r => r.v);
}
function getOrderedNums(card, selector, limit){
  return Array.from(card.querySelectorAll(selector))
    .map(el => parseInt(String(el.textContent).trim(), 10))
    .filter(Number.isFinite)
    .slice(0, limit|0);
}
function numberTags(n, provenance){
  const tags = [];
  if (provenance.hit) tags.push('[[span class="btag btag-hit"]]*HIT*[[/span]]');
  if (provenance.ovl) tags.push('[[span class="btag btag-ovl"]]OVL[[/span]]');
  if (provenance.ai)  tags.push('[[span class="btag btag-ai"]]AI[[/span]]');
  if (provenance.sh)  tags.push('[[span class="btag btag-sh"]]SH[[/span]]');
  if (provenance.sk)  tags.push('[[span class="btag btag-sk"]]SKAI[[/span]]');
  if (provenance.mm)  tags.push('[[span class="btag btag-mm"]]MCMC[[/span]]');
  if (provenance.hm)  tags.push('[[span class="btag btag-hm"]]HM[[/span]]');
  return tags.length ? '[[span class="ball-tags"]]' + tags.join('') + '[[/span]]' : '';
}

function buildChip(n, provenance){
  return '[[span class="ball"]]' + n + numberTags(n, provenance) + '[[/span]]';
}


// Build per-method candidate pools from peak ranks in CURRENT selection
var candidatesByMethod = {
  skip_hit:        [],
  ai_prediction:   [],
  skai_prediction: [],
  mcmc_prediction: [],
  heatmap:         []
};

methods.forEach(function(m){
  var selectedCards = checked
    .map(cb => cb.closest('.prediction-card'))
    .filter(card => card && String(card.getAttribute('data-source')||'') === m);

  if (!selectedCards.length) return;

  var row = selStats[m].main;
  var peak = topRanksWithTies(row, 3, 3);
  var ranks = peak.ranks;
  if (!ranks.length) return;

  selectedCards.forEach(function(card){
    var list = getOrderedNums(card, '.match-pill:not(.extra), .no-match:not(.extra)', maxMain);
    ranks.forEach(function(r){
      if (r >= 1 && r <= list.length){
        candidatesByMethod[m].push(list[r-1]);
      }
    });
  });
});

// Build EXTRA candidate pools (if any)
var candidatesExtraByMethod = {
  skip_hit:        [],
  ai_prediction:   [],
  skai_prediction: [],
  mcmc_prediction: [],
  heatmap:         []
};
methods.forEach(function(m){
  var selectedCards = checked
    .map(cb => cb.closest('.prediction-card'))
    .filter(card => card && String(card.getAttribute('data-source')||'') === m);

  if (!selectedCards.length) return;

  var rowE = selStats[m].extra;
  var peakE = topRanksWithTies(rowE, 2, 2); // require ≥2 hits

  var ranksE = peakE.ranks;
  if (!ranksE.length) return;

  selectedCards.forEach(function(card){
    var listE = getOrderedNums(card, '.match-pill.extra, .no-match.extra', maxExtra);
    ranksE.forEach(function(r){
      if (r >= 1 && r <= listE.length){
        candidatesExtraByMethod[m].push(listE[r-1]);
      }
    });
  });
});

// Overlap sets
var overlapSetMain  = new Set(commonsMain);
var overlapSetExtra = new Set(commonsExtra);

// MAIN recommendations:
// 1) Overlap Core
var recMain = unique(commonsMain);

// 2) Method Sweet-Spot Boosters (up to 2 per method, excluding already added)
methods.forEach(function(m){
  if (!candidatesByMethod[m].length) return;
  var fm = freqMap(candidatesByMethod[m]);
  var top = topByFreq(fm, 2, new Set(recMain));
  recMain = recMain.concat(top);
});
recMain = unique(recMain);

// 3) Mid-Rank Value (ranks 4–10 across all selected cards, ≥2 appearances, excluding current recs)
var midRankNums = [];
checked.forEach(function(cb){
  var card = cb.closest('.prediction-card');
  var list = getOrderedNums(card, '.match-pill:not(.extra), .no-match:not(.extra)', maxMain);
  list.forEach(function(v, idx){
    var r = idx+1;
    if (r >= 4 && r <= 10) midRankNums.push(v);
  });
});
var midFM = freqMap(midRankNums);
var midCandidates = Object.keys(midFM).map(k => ({v:parseInt(k,10), c:midFM[k]}))
  .filter(x => x.c >= 2 && recMain.indexOf(x.v) === -1)
  .sort(function(a,b){ return (b.c - a.c) || (a.v - b.v); })
  .map(x => x.v);
var recMid = take(midCandidates, 4);

// 4) Outliers (top-rank single-method, non-overlap, limited)
var topRankSingles = [];
checked.forEach(function(cb){
  var card = cb.closest('.prediction-card');
  var list = getOrderedNums(card, '.match-pill:not(.extra), .no-match:not(.extra)', maxMain);
  if (list.length) topRankSingles.push(list[0]);
});
var outlierFM = freqMap(topRankSingles);
var outliers = Object.keys(outlierFM).map(k => parseInt(k,10))
  .filter(v => !overlapSetMain.has(v) && recMain.indexOf(v) === -1 && recMid.indexOf(v) === -1);
var recOutliers = take(outliers, 2);

// Final MAIN recommendation list (ordered: Overlap → Peaks → Mid → Outliers)
var finalMain = unique([].concat(recMain, recMid, recOutliers));

// EXTRA recommendations: Overlap → method peaks (1 per method) → extras with ≥2 mid ranks (if applicable)
var recExtra = unique(commonsExtra);
methods.forEach(function(m){
  if (!candidatesExtraByMethod[m].length) return;
  var fm = freqMap(candidatesExtraByMethod[m]);
  var top = topByFreq(fm, 1, new Set(recExtra));
  recExtra = recExtra.concat(top);
});
recExtra = unique(take(recExtra, 3)); // cap extras displayed

// Build placement profile text from bits (e.g., “AI peaks near #4 & #7 (62%)”)
var placementLine = bits.length
  ? ('Placement profile: ' + bits.join('; ') + '.')
  : 'Placement profile: not enough selected history to locate sweet spots.';

// Update Decision Strip (top bar) for this lottery group
var decisionStrip = group.querySelector('[data-decision-strip]');
if (decisionStrip) {
  var mainsSlot   = decisionStrip.querySelector('[data-decision-mains]');
  var extrasSlot  = decisionStrip.querySelector('[data-decision-extras]');
  var modeSlot    = decisionStrip.querySelector('[data-decision-mode-label]');
  var confSlot    = decisionStrip.querySelector('[data-decision-confidence]');
  var noteSlot    = decisionStrip.querySelector('[data-decision-note]');
  var extraBlock  = decisionStrip.querySelector('[data-decision-extra-block]');

  // Mode label (pre vs post draw)
  if (modeSlot) {
    modeSlot.textContent = (mode === 'post') ? 'Completed draw' : 'Upcoming draw';
  }

  // DISABLED: Recommended mains section rendering
  // Reason: Section displays only raw numbers with no dashes and is confusing.
  // Commenting out to prevent population of the data-decision-mains element.
  // Code preserved for potential future re-enabling if improved.
  /*
  if (mainsSlot) {
    if (finalMain.length) {
      mainsSlot.innerHTML = finalMain.map(function(n){
        var isHit = (mode === 'post') && (drawnMain.indexOf(n) !== -1 || drawnExtra.indexOf(n) !== -1);
        var isOvl = commonsMain.indexOf(n) !== -1;
        var cls   = 'decision-pill';
        if (isHit) {
          cls += ' decision-pill-hit';
        } else if (isOvl) {
          cls += ' decision-pill-overlap';
        }
        return '<span class="' + cls + '">' + String(n) + '</span>';
      }).join('');
    } else {
      mainsSlot.innerHTML =
        '<span class="decision-pill decision-pill-empty">' +
        'Not enough history yet — keep running methods to build a profile.' +
        '</span>';
    }
  }
  */// END DISABLED: Recommended mains section rendering

  // DISABLED: Recommended extras section rendering
  // Reason: Section displays bunched up numbers similar to mains issue.
  // Commenting out to prevent population of the data-decision-extras element.
  // Code preserved for potential future re-enabling if improved.
  /*
  // Recommended extras (if any)
  if (extrasSlot && extraBlock) {
    if (recExtra.length) {
      extraBlock.style.display = '';
      extrasSlot.innerHTML = recExtra.map(function(n){
        var isHit = (mode === 'post') && (drawnExtra.indexOf(n) !== -1);
        var isOvl = commonsExtra.indexOf(n) !== -1;
        var cls   = 'decision-pill decision-pill-extra';
        if (isHit) {
          cls += ' decision-pill-hit';
        } else if (isOvl) {
          cls += ' decision-pill-overlap';
        }
        return '<span class="' + cls + '">' + String(n) + '</span>';
      }).join('');
    } else {
      // hide the extras block when nothing meaningful to say
      extraBlock.style.display = 'none';
    }
  }
  */// END DISABLED: Recommended extras section rendering

// Confidence heuristics: simple, transparent, and stable
  var methodsUsed   = methods.filter(function(m){ return selStats[m].runs > 0; }).length;
  var overlapScore  = commonsMain.length + commonsExtra.length;
  var evidenceScore = bits.length;

  // Confidence is locked as Hybrid (Agreement × Historical Validation).
  // The "level" is what changes based on evidence quality.
  var levelLabel = 'Exploratory';
  var levelNote  = 'Good for exploring ideas — keep building more history.';

  // Brand-honest single-selection state (no “agreement” possible)
  if (checked.length === 1) {
    levelLabel = 'Single-method';
    levelNote  = 'Based on the selected method only. Add another method to measure agreement and strengthen confidence.';
  } else if (methodsUsed >= 2 && overlapScore >= 3 && evidenceScore >= 2) {
    levelLabel = 'High';
    levelNote  = 'Strong agreement between methods with consistent hot spots.';
  } else if (methodsUsed >= 2 && (overlapScore >= 1 || evidenceScore >= 1)) {
    levelLabel = 'Balanced';
    levelNote  = 'Solid mix of agreement and proven ranks — suitable as a core set.';
  }

  // Locked confidence definition (always shown)
  if (confSlot) { confSlot.textContent = 'Hybrid (Agreement × Historical Validation)'; }

  // Level + explanation (what changes)
  if (noteSlot) { noteSlot.textContent = 'Level: ' + levelLabel + ' — ' + levelNote; }
}

// REMOVED: Field coverage view calculations
// Reason: Redundant and not useful. This entire section has been removed.
// Original code calculated and displayed all numbers used by any selected method.
// Removal includes: coverageMap calculation, coverage display logic, and UI population.
// Code block originally at lines ~5283-5357 removed entirely.

// Overlap summary line already computed → overlapLine

// Build provenance map for chips (what tags apply to each number)
function provenanceFor(n){
  return {
    hit: drawnMain.includes(n) || drawnExtra.includes(n),
    ovl: overlapSetMain.has(n) || overlapSetExtra.has(n),
    ai:  (candidatesByMethod.ai_prediction   || []).includes(n),
    sh:  (candidatesByMethod.skip_hit        || []).includes(n),
    sk:  (candidatesByMethod.skai_prediction || []).includes(n),
    mm:  (candidatesByMethod.mcmc_prediction || []).includes(n),
    hm:  (candidatesByMethod.heatmap         || []).includes(n)
  };
}

// ---------- Compose structured HTML ----------
var html = '';

// Headline area: Post shows recap; Pre shows recommended head list
if (mode === 'post') {
  var drawnMainText  = drawnMain.length  ? ('Drawn mains: ' + drawnMain.join(', ')) : 'Drawn mains: n/a';
  var drawnExtraText = drawnExtra.length ? (' • ' + (window.extraLabel || 'Extras') + ': ' + drawnExtra.join(', ')) : '';
  html += '[[div class="s-row subtle"]][[strong]]Result Recap:[[/strong]] ' + drawnMainText + drawnExtraText + '.[[/div]]';
} else {
  var headMain  = finalMain.length ? ('Mains: ' + take(finalMain, 8).join(', ')) : 'Mains: —';
  var headExtra = recExtra.length   ? (' • ' + (window.extraLabel || 'Extras') + ': ' + recExtra.join(', ')) : '';
  html += '[[div class="s-row subtle"]][[strong]]Recommended Focus:[[/strong]] ' + headMain + headExtra + '.[[/div]]';
}

// ===== Summary (bold) =====
var overlapParts = [];
if (checked.length >= 2) {
  if (commonsMain.length) { overlapParts.push(commonsMain.length + ' ' + (commonsMain.length===1?'main overlap':'main overlaps')); }
  if (commonsExtra.length){ overlapParts.push(commonsExtra.length + ' ' + (commonsExtra.length===1?'extra overlap':'extra overlaps')); }
}

// Build method evidence lines for the CURRENT selection
var evidenceLines = [];
methods.forEach(function(m){
  var rowM = selStats[m].main, rowE = selStats[m].extra;
  var totalM = sumObjectVals(rowM);
  var totalE = sumObjectVals(rowE);
  var runs   = selStats[m].runs|0;
  if (!runs) return;

  // Peaks with minimum totals (mains>=3, extras>=2)
  var pkM = topRanksWithTies(rowM, 3, 3);
  var pkE = topRanksWithTies(rowE, 2, 2);

  var line = labelShort[m] + ' — ';
  line += 'Main hits: ' + totalM;
  if (drawnExtra.length) line += ' • Extra hits: ' + totalE;

  if (pkM.ranks.length) line += ' ; peaks (mains): ' + fmtRankList(pkM.ranks);
  if (drawnExtra.length && pkE.ranks.length) line += ' ; peaks (extras): ' + fmtRankList(pkE.ranks);
  line += '.';
  evidenceLines.push(line);
});

// Placement line for summary
var placementLine = bits.length
  ? ('Placement profile: ' + bits.join('; ') + '.')
  : 'Placement profile: not enough selected history to locate sweet spots.';

var overlapShort = overlapParts.length ? (' Overlap across selected: ' + overlapParts.join(' + ') + '.') : '';

var summaryLine;
if (mode === 'post') {
  var core = placementLine.replace(/^Placement profile:\s*/i, '') + overlapShort;
  summaryLine = 'Looking back at this draw, ' + core.replace(/^\s+/, '');
} else {
  var peakSummary = bits.length
    ? bits.join('; ') + '.'
    : 'there is not enough selected history yet to locate clear sweet spots.';
  var overlapIntro = overlapParts.length
    ? ('Overlaps are strong — ' + overlapParts.join(' + ') + '. ')
    : '';

  // Brand-honest single-selection state
  if (checked.length === 1) {
    overlapIntro = 'Selected method numbers (single-run view). ';
  }

  summaryLine = 'Right now, ' + overlapIntro + peakSummary;
}

html += '[[div class="section-h"]][[strong]]Quick Summary:[[/strong]][[/div]]' +
        '[[div class="bullet"]]' + summaryLine + '[[/div]]';

// ===== Evidence (bold): clear, one per line =====
html += '[[div class="section-h"]][[strong]]Evidence Check:[[/strong]][[/div]]';
if (evidenceLines.length) {
  html += '[[ul style="margin:0 0 .5rem 1.25rem; padding:0;"]]' +
          evidenceLines.map(function(l){ return '[[li]]' + l + '[[/li]]'; }).join('') +
          '[[/ul]]';
} else {
  html += '[[div class="bullet"]][[em]]Not enough selected history yet to build an evidence list — keep saving more runs.[[/em]][[/div]]';
}

// Recommended numbers (chips) — same order logic
if (finalMain.length){
  html += '[[div class="bullet"]][[em]]Recommended mains (overlaps, method peaks, and mid-rank value):[[/em]][[/div]]' +
          '[[div class="chips"]]';
  finalMain.forEach(function(n){ html += buildChip(n, provenanceFor(n)); });
  html += '[[/div]]';
}

if (recExtra.length){
  html += '[[div class="bullet"]][[em]]Recommended ' + (window.extraLabel || 'extras') + ':[[/em]][[/div]]' +
          '[[div class="chips"]]';
  recExtra.forEach(function(n){ html += buildChip(n, provenanceFor(n)); });
  html += '[[/div]]';
}


// ===== Recommendation (bold) =====
var recText;
if (mode === 'post') {
  // Post-draw: use what just happened to tune the next play
  recText = '[[strong]]How to use this draw:[[/strong]] [[ol]]' +
            '[[li]]Build your core from numbers that show up in more than one method — when methods agree, that signal is stronger.[[/li]]' +
            '[[li]]Lean on the “hot spot” ranks where your methods actually hit the winning numbers (especially around #1–#5).[[/li]]' +
            '[[li]]Do not only stack #1 picks — keep some middle-rank numbers (#4–#10) in the mix for balance.[[/li]]' +
            '[[/ol]] [[em]]This is guidance, not a guarantee — it simply tilts your strategy toward the patterns that have worked most often.[[/em]]';
} else {
  // Pre-draw: guidance before the next results land
  recText = '[[strong]]For your upcoming plays:[[/strong]] [[ol]]' +
            '[[li]]Start with numbers that more than one method likes — overlap is your “agreement” signal.[[/li]]' +
            '[[li]]Add a few “hot spot” ranks from each method (where they tend to perform best), not just the top rank.[[/li]]' +
            '[[li]]Mix in middle-rank numbers (#4–#10) so your ticket is not all-in on only the very top picks.[[/li]]' +
            '[[/ol]] [[em]]Think of this as a coach’s game plan — it helps you structure your choices, but it never promises a specific outcome.[[/em]]';
}

html += '[[div class="section-h"]][[strong]]Recommendation:[[/strong]][[/div]]' +
        '[[div class="bullet"]]' + recText + '[[/div]]';

// =============================
// SKAI Living Engine (per lottery)
// =============================
var lotteryId = group.getAttribute('data-lottery-id') || 'unknown';

// Record a compact “run summary” (bounded history)
var entry = {
  ts: (new Date()).toISOString(),
  mode: mode,
  checkedLen: checked.length,
  methodsUsed: methodsUsed,
  overlapScore: overlapScore,
  evidenceScore: evidenceScore,
  levelLabel: levelLabel
};

var historyArr = skaiLiveAppend(lotteryId, entry, 12);

// Reset learning link (per lottery) — clears only the learning/trend memory
html += '[[div class="bullet" style="margin-top:0.65rem;"]]';
html += '[[a href="#" data-skai-reset-learning="1" data-lottery-id="' + String(lotteryId) + '"';
html += ' style="color:#6b7280; text-decoration:underline; font-size:0.9rem;"';
html += ' aria-label="Reset learning history for this lottery"';
html += ']]Reset learning for this lottery[[/a]]';
html += '[[/div]]';

// Trend sentences (simple, ninth-grader readable)
var trendAgreement = skaiTrendSentence(historyArr, 'overlapScore', 'Agreement');
var trendEvidence  = skaiTrendSentence(historyArr, 'evidenceScore', 'Evidence');
var trendConf      = skaiConfidenceTrend(historyArr);

// Posture + next steps (mapped to existing user actions)
var posture = skaiPosture(levelLabel, methodsUsed, overlapScore, evidenceScore);
var nextSteps = skaiNextSteps(levelLabel, checked.length, methodsUsed, overlapScore, evidenceScore);

// Append “Learning” sections to the narrative
html += '[[div class="section-h"]][[strong]]What the data showed:[[/strong]][[/div]]';

if (trendAgreement || trendEvidence) {
  html += '[[div class="bullet"]]' +
    (trendAgreement ? (trendAgreement + ' ') : '') +
    (trendEvidence ? trendEvidence : '') +
  '[[/div]]';
} else {
  html += '[[div class="bullet"]][[em]]Not enough history yet to measure direction — save a few more runs to unlock trends.[[/em]][[/div]]';
}

if (trendConf) {
  html += '[[div class="bullet"]]' + trendConf + '[[/div]]';
}

html += '[[div class="section-h"]][[strong]]What this tells us:[[/strong]][[/div]]' +
        '[[div class="bullet"]]' + posture + '[[/div]]' +
        '[[div class="bullet"]][[em]]Built on probabilities — not promises.[[/em]][[/div]]';

html += '[[div class="section-h"]][[strong]]What to try next:[[/strong]][[/div]]';

if (nextSteps && nextSteps.length) {
  html += '[[ul style="margin:0 0 .5rem 1.25rem; padding:0;"]]';
  nextSteps.forEach(function(s){
    html += '[[li]]' + String(s) + '[[/li]]';
  });
  html += '[[/ul]]';
} else {
  html += '[[div class="bullet"]][[em]]No changes suggested right now — this is a reasonable baseline.[[/em]][[/div]]';
}

// Render structured narrative (Sorcerer [[..]] → HTML)
// Also mark it as a live status region for assistive tech.
if (narrativeEl) {
  narrativeEl.setAttribute('role', 'status');
  narrativeEl.setAttribute('aria-live', 'polite');
  narrativeEl.innerHTML = S(html);
}
      }
    }
  });
  
// — Settings panels: default COLLAPSED; persist per run —
// Use delegation so clicks work reliably on mobile and future DOM changes.
document.addEventListener('click', (ev) => {
  const toggle = ev.target.closest('.settings-toggle');
  if (!toggle) return;

  const card  = toggle.closest('.prediction-card');
  if (!card) return;
  const panel = card.querySelector('.settings-panel');
  if (!panel) return;

  const id     = card.getAttribute('data-set-id') || '';
  const openKey = 'settingsOpen_' + id;

  // Current open/closed from DOM (default collapsed)
  let isOpen = panel.classList.contains('open');

  // Toggle
  isOpen = !isOpen;
  panel.classList.toggle('open', isOpen);
  panel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
  toggle.textContent = isOpen ? 'Hide Details' : 'Details';
  toggle.setAttribute('title', isOpen ? 'Hide details' : 'Show details');
  toggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');

  try { localStorage.setItem(openKey, String(isOpen)); } catch(e){}
});

// Initialize panels from storage after DOM is ready
// (deduped: we are already inside the top-level DOMContentLoaded handler)
document.querySelectorAll('.prediction-card').forEach(card => {
  const id    = card.getAttribute('data-set-id') || '';
  const panel = card.querySelector('.settings-panel');
  const toggle= card.querySelector('.settings-toggle');
  if (!panel || !toggle) return;

  const openKey = 'settingsOpen_' + id;
  // Default: panels start CLOSED on every load
  let isOpen = false;

  panel.classList.toggle('open', isOpen);
  panel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
  toggle.textContent = isOpen ? '⚙️ Hide Settings' : '⚙️ Show Settings';
  toggle.setAttribute('title', isOpen ? 'Hide Settings' : 'Show Settings');
  toggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
});

 
// — Compare All button functionality (robust change firing) —
var compareAllBtn = document.getElementById('compare-all-btn');

function fireFormEvents(el) {
  // Fire both 'input' and 'change' with bubbling to ensure listeners run
  ['input', 'change'].forEach(function(type) {
    el.dispatchEvent(new Event(type, { bubbles: true, cancelable: true }));
  });
}

if (compareAllBtn) {
  compareAllBtn.addEventListener('click', function() {
    var boxes = document.querySelectorAll('.card-compare-checkbox');

    // 1) check them all first (sync)
    Array.prototype.forEach.call(boxes, function(cb){ cb.checked = true; });

    // 2) then, on the next frame, fire the events so the DOM state is settled
    requestAnimationFrame(function() {
      Array.prototype.forEach.call(boxes, function(cb) {
        ['input', 'change'].forEach(function(type) {
          cb.dispatchEvent(new Event(type, { bubbles: true, cancelable: true }));
        });
      });

      // 3) safety nudge per group to ensure its local update() runs
      Array.prototype.forEach.call(
        document.querySelectorAll('.lottery-group'),
        function(group) {
          var first = group.querySelector('.card-compare-checkbox');
          if (first) {
            ['input', 'change'].forEach(function(type) {
              first.dispatchEvent(new Event(type, { bubbles: true, cancelable: true }));
            });
          }
        }
      );
    });
  });
}

// Convert all timestamps to user's local timezone
// This runs after the DOM is loaded to convert ISO timestamps to local time
function convertTimestampsToLocal() {
  document.querySelectorAll('.local-time').forEach(function(el) {
    var container = el.closest('[data-timestamp]');
    if (!container) return;
    
    var isoTime = container.getAttribute('data-timestamp');
    if (!isoTime) return;
    
    try {
      var date = new Date(isoTime);
      if (isNaN(date.getTime())) return;
      
      // Format: "Dec 30, 2025, 3:45pm"
      var options = {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      };
      
      var localTime = date.toLocaleString('en-US', options);
      el.textContent = localTime;
    } catch (e) {
      // If conversion fails, leave the original timestamp
      console.error('Failed to convert timestamp:', isoTime, e);
    }
  });
}

// Run timestamp conversion after DOM is ready
convertTimestampsToLocal();

// Lottery section collapse/expand functionality
// Persists state in localStorage per lottery
function initLotteryCollapse() {
  document.querySelectorAll('.lottery-group').forEach(function(group) {
    var toggle = group.querySelector('.lottery-collapse-toggle');
    if (!toggle) return;
    
    var lotteryId = group.getAttribute('data-lottery-id');
    if (!lotteryId) return;
    
    var storageKey = 'lottery_collapsed_' + lotteryId;
    
    // Restore collapsed state from localStorage
    try {
      var isCollapsed = localStorage.getItem(storageKey) === 'true';
      if (isCollapsed) {
        group.classList.add('collapsed');
        toggle.textContent = '▶ Expand';
        toggle.setAttribute('aria-expanded', 'false');
        toggle.setAttribute('aria-label', 'Expand lottery section');
      }
    } catch (e) {
      // localStorage not available, ignore
    }
    
    // Handle toggle click
    toggle.addEventListener('click', function() {
      var isCurrentlyCollapsed = group.classList.contains('collapsed');
      
      if (isCurrentlyCollapsed) {
        // Expand
        group.classList.remove('collapsed');
        toggle.textContent = '▼ Collapse';
        toggle.setAttribute('aria-expanded', 'true');
        toggle.setAttribute('aria-label', 'Collapse lottery section');
        try {
          localStorage.setItem(storageKey, 'false');
        } catch (e) {}
      } else {
        // Collapse
        group.classList.add('collapsed');
        toggle.textContent = '▶ Expand';
        toggle.setAttribute('aria-expanded', 'false');
        toggle.setAttribute('aria-label', 'Expand lottery section');
        try {
          localStorage.setItem(storageKey, 'true');
        } catch (e) {}
      }
    });
  });
}

// Initialize lottery collapse functionality
initLotteryCollapse();

// close the top-level DOMContentLoaded wrapper opened at the start of this script
});

[[/script]]

<!-- ==================================================
     Favorite Lotteries Section
     ================================================== -->
[[div id="favorite-lotteries" class="favorite-lotteries-grid"]]

[[details open class="card favorites-wrapper"]]
  [[summary class="card-header favorite-lotteries-header"]]
    [[div style="display:flex; align-items:center; justify-content:space-between; width:100%; flex-wrap:wrap;"]]
      [[div style="display:flex; align-items:center; gap:10px;"]]
        [[span class="title"]]Your Favorite Lotteries[[/span]]
        [[span class="section-badge"]]<?php echo count($favoriteLotteries); ?>[[/span]]
      [[/div]]
      [[a href="/select-favorite-lotteries" class="btn-primary"]]+ Edit[[/a]]
    [[/div]]
  [[/summary]]

  [[div id="favorites-list"]]
 
    <?php if (!empty($favoriteLotteries)): ?>
      [[div class="favorites-grid"]]
        <?php foreach ($favoriteLotteries as $lotto): ?>
          <?php
            // Attempt to load the latest draw info for each favorite lottery
            $drawingInfo = getLatestDrawing($lotto['game_id'], $db);

            // Sanitize the URL for “View Results”
            $url = htmlspecialchars(trim($lotto['lottery_urls']), ENT_QUOTES, 'UTF-8');

            // Default placeholders
            $lastDraw  = 'N/A';
            $nextDraw  = 'N/A';
            $drawnStr  = 'N/A';

            if (!empty($drawingInfo)) {
                $lastDraw = !empty($drawingInfo['draw_date'])
                    ? date('M j, Y', strtotime($drawingInfo['draw_date']))
                    : 'N/A';
                $nextDraw = !empty($drawingInfo['next_draw_date'])
                    ? date('M j, Y', strtotime($drawingInfo['next_draw_date']))
                    : 'N/A';

                // Known metadata fields to skip
                $metaFields = [
                    'id','asset_id','state','ordering','checked_out','checked_out_time',
                    'created_by','modified_by','country','stateprov_name','stateprov_id',
                    'game_id','game_name','draw_date','next_draw_date','next_jackpot'
                ];

                // Gather drawn numbers
                $drawn = [];
                foreach ($drawingInfo as $k => $v) {
                    if (!in_array($k, $metaFields, true) && $v !== '' && preg_match('/^\d+$/', $v)) {
                        $drawn[] = $v;
                    }
                }
                $drawnStr = implode(', ', $drawn) ?: 'N/A';
            }

            // Determine an optional “type badge” (e.g., “Powerball”)
            $typeBadge = '';
            $nameLower = mb_strtolower($lotto['lottery_name'], 'UTF-8');
            if (strpos($nameLower, 'pick 3') !== false) {
                $typeBadge = 'Pick 3';
            } elseif (strpos($nameLower, 'pick 4') !== false) {
                $typeBadge = 'Pick 4';
            } elseif (strpos($nameLower, 'powerball') !== false) {
                $typeBadge = 'Powerball';
            } elseif (strpos($nameLower, 'mega') !== false) {
                $typeBadge = 'Mega Millions';
            }
          ?>

[[div class="card favorite-card"]]
  [[div class="card-header"]]
    <?php
      $favLogo = ['path'=>'','exists'=>false,'alt'=>''];
      if (!empty($lotto['state_name']) && !empty($lotto['lottery_name'])) {
          $favLogo = buildLotteryLogoPath((string)$lotto['state_name'], (string)$lotto['lottery_name']);
      }
    ?>

    [[div class="lotto-title-wrap"]]
      <?php if (!empty($favLogo['path'])): ?>
        <?php if ($favLogo['exists']): ?>
          [[img class="lotto-logo" src="<?php echo htmlspecialchars($favLogo['path'], ENT_QUOTES); ?>"
                alt="<?php echo htmlspecialchars($favLogo['alt'], ENT_QUOTES); ?>" loading="lazy" width="120" height="38"]]
        <?php else: ?>
          [[span class="lotto-logo fallback" aria-label="<?php echo htmlspecialchars($favLogo['alt'].' (placeholder)', ENT_QUOTES); ?>"]]
            <?php
              $parts = preg_split('/\s+/', (string)$lotto['lottery_name']);
              $ini   = '';
              foreach ($parts as $p) { if ($p !== '') { $ini .= mb_strtoupper(mb_substr($p,0,1)); if (mb_strlen($ini) >= 2) break; } }
              echo htmlspecialchars($ini ?: 'LE', ENT_QUOTES);
            ?>
          [[/span]]
        <?php endif; ?>
      <?php endif; ?>

      [[span class="title"]]
        <?php echo htmlspecialchars($lotto['country_name'], ENT_QUOTES); ?> • <?php echo htmlspecialchars($lotto['state_name'], ENT_QUOTES); ?> • [[strong]]<?php echo htmlspecialchars($lotto['lottery_name'], ENT_QUOTES); ?>[[/strong]][[br]]• Last: <?php echo $lastDraw; ?>
      [[/span]]
    [[/div]]
  [[/div]]


            [[div class="lottery-details"]]
              📍 <?php echo htmlspecialchars($lotto['state_name'], ENT_QUOTES, 'UTF-8'); ?>, <?php echo htmlspecialchars($lotto['country_name'], ENT_QUOTES, 'UTF-8'); ?>
            [[/div]]

            [[div class="draw-info"]]
              Last Draw: [[strong]]<?php echo $lastDraw; ?>[[/strong]][[br]]
              Next Draw: [[strong]]<?php echo $nextDraw; ?>[[/strong]][[br]]
              Numbers: [[strong]]<?php echo htmlspecialchars($drawnStr, ENT_QUOTES, 'UTF-8'); ?>[[/strong]]
            [[/div]]

             [[div style="margin-top:.75rem; display:flex; justify-content:flex-end;"]]
               <?php if ($url !== ''): ?>
                 [[a href="<?php echo $url; ?>" target="_blank" class="btn-primary"]]View Results[[/a]]
               <?php endif; ?>
             [[/div]]

          [[/div]]

        <?php endforeach; ?>
      [[/div]]
    <?php else: ?>
      [[p class="text-muted"]]No favorite lotteries found.[[/p]]
    <?php endif; ?>
  [[/div]]
[[/details]]
[[/div]]


<!-- ==================================================
     Wheeling Preferences Section 
     ================================================== -->
[[details open class="card wheeling-card"]]
  [[summary class="card-header"]]
    [[div style="display:flex; justify-content:space-between; align-items:center; width:100%; flex-wrap:wrap; gap:1rem;"]]
      [[div style="display:flex; align-items:center; gap:10px;"]]
        [[span class="title"]]Your Wheeling Preferences[[/span]]
        [[span class="section-badge"]]<?php echo count($favWheelingSystems); ?>[[/span]]
      [[/div]]
      [[a href="/my-wheeling-systems" class="btn-primary"]]+ Edit[[/a]]
    [[/div]]
  [[/summary]]

  <?php if (!empty($favWheelingSystems)): ?>
    [[div class="saved-cards-grid"]]
      <?php foreach ($favWheelingSystems as $sys): ?>
        <?php
          $gamesCount = is_numeric($sys['games']) ? (int)$sys['games'] : 'N/A';
          $url = htmlspecialchars(trim($sys['url']), ENT_QUOTES, 'UTF-8') ?: '#';
        ?>
        [[div class="card" style="border:1px solid #e0e0e0; padding:1rem; display:flex; flex-direction:column; background:#fdfdfd;"]]
          [[div style="font-size:1.1rem; font-weight:bold; margin-bottom:.5rem;"]]
            [[a href="<?php echo $url; ?>" target="_blank" class="lottery-link"]]
              <?php echo htmlspecialchars($sys['name'], ENT_QUOTES, 'UTF-8'); ?>
            [[/a]]
          [[/div]]
          [[div style="font-size:.9rem; color:#555; line-height:1.6;"]]
            [[strong]]Pick Size:[[/strong]] <?php echo htmlspecialchars($sys['pick_size'], ENT_QUOTES, 'UTF-8'); ?>[[br]]
            [[strong]]Number Range:[[/strong]] <?php echo htmlspecialchars($sys['number_range'], ENT_QUOTES, 'UTF-8'); ?>[[br]]
            [[strong]]Assurance:[[/strong]] <?php echo htmlspecialchars($sys['assurance'], ENT_QUOTES, 'UTF-8'); ?>[[br]]
            [[strong]]Total Games:[[/strong]] <?php echo $gamesCount; ?>
          [[/div]]
        [[/div]]
      <?php endforeach; ?>
    [[/div]]
  <?php else: ?>
    [[p class="text-muted" style="margin-top:1rem;"]]No favorite wheeling systems selected.[[/p]]
  <?php endif; ?>
[[/details]]

[[/div]]
[[script]]
  function scrollToFavorites() {
    var el = document.getElementById('favorite-lotteries');
    if (!el) {
      return;
    }

    // Respect users who prefer reduced motion
    var prefersReduced =
      window.matchMedia &&
      window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    if (prefersReduced) {
      // Jump without animation
      el.scrollIntoView(true);
    } else if (el.scrollIntoView) {
      try {
        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
      } catch (e) {
        // Fallback for older browsers
        el.scrollIntoView(true);
      }
    }

    // Make the region programmatically focusable and move focus for screen readers
    if (!el.hasAttribute('tabindex')) {
      el.setAttribute('tabindex', '-1');
    }
    try {
      el.focus();
    } catch (e) {}

    el.classList.add('highlighted-scroll');
    setTimeout(function () {
      el.classList.remove('highlighted-scroll');
    }, 2000);
  }
[[/script]]

[[script]]
// ============================================================
// Best Settings Snapshot: jump handlers
// "View best" scrolls to a prediction card; "All runs" scrolls
// to the lottery group. ES5-compatible.
// ============================================================
(function initSnapshotJumps() {
  var snap = document.getElementById('skai-global-snapshot');
  if (!snap) { return; }

  snap.addEventListener('click', function (ev) {
    var btn = ev.target;
    if (!btn || btn.tagName !== 'BUTTON') { return; }

    // Helper: smooth scroll with fallback for older browsers
    function scrollTo(el) {
      if (!el) { return; }
      try {
        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
      } catch (e) {
        el.scrollIntoView(true);
      }
    }

    // "View best" — jump to the prediction card for this run
    if (btn.classList.contains('skai-bss-view-btn')) {
      var runId = btn.getAttribute('data-jump-run-id') || '';
      var lid   = btn.getAttribute('data-jump-lottery-id') || '';
      if (runId) {
        // Look for the card by data-set-id first
        var card = document.querySelector('[data-set-id="' + runId + '"]');
        if (card) {
          scrollTo(card);
          return;
        }
      }
      // Fallback: scroll to the lottery group
      if (lid) {
        var grps = document.querySelectorAll('.lottery-group');
        for (var i = 0; i < grps.length; i++) {
          var grpLid = (grps[i].getAttribute('data-lottery-id') || '').split('-')[0];
          if (grpLid === String(lid)) {
            scrollTo(grps[i]);
            return;
          }
        }
      }
    }

    // "All runs" — jump to the lottery group for this lottery
    if (btn.classList.contains('skai-bss-all-link')) {
      var crrId = btn.getAttribute('data-jump-crr-id') || '';
      if (crrId) {
        var grps2 = document.querySelectorAll('.lottery-group');
        for (var j = 0; j < grps2.length; j++) {
          var grpLid2 = (grps2[j].getAttribute('data-lottery-id') || '').split('-')[0];
          if (grpLid2 === String(crrId)) {
            scrollTo(grps2[j]);
            return;
          }
        }
      }
    }
  });
})();
[[/script]]

[[script]]
// ============================================================
// DEBUG: Prediction Results section diagnostics.
// Set to true to log draw-lookup details to the console.
// ES5-compatible; safe to leave in production (false = silent).
// ============================================================
var DEBUG_PRED_RESULTS = false;
// Override via URL query string: append ?debug_pred_results=1 to enable without redeployment
if (window.location.search && window.location.search.indexOf('debug_pred_results=1') !== -1) {
  DEBUG_PRED_RESULTS = true;
}

(function () {
  if (!DEBUG_PRED_RESULTS) { return; }
  var sections = document.querySelectorAll('.prc-section');
  for (var i = 0; i < sections.length; i++) {
    var sec = sections[i];
    var pending = sec.querySelectorAll('.prc-row-pending');
    var total   = sec.querySelectorAll('tbody tr:not(.prc-section-subhead)');
    console.log('[PRED-RESULTS] section:', sec.id,
      '| total rows:', total.length,
      '| upcoming rows:', pending.length);
    var upcomingRows = sec.querySelectorAll('tr.prc-row-pending');
    for (var j = 0; j < upcomingRows.length; j++) {
      var cells = upcomingRows[j].querySelectorAll('td');
      console.log('  [UPCOMING] draw date:', cells[1] ? cells[1].textContent.trim() : '?',
        'method:', cells[2] ? cells[2].textContent.trim() : '?');
    }
  }
}());

// ============================================================
// skaiPrcToggle: Collapse / expand a prediction-results table section.
// ES5-compatible; no dependencies.
// ============================================================
function skaiPrcToggle(sectionId) {
  var sec  = document.getElementById(sectionId);
  if (!sec) { return; }
  var body = document.getElementById(sectionId + '-body');
  var hdr  = sec.querySelector('.prc-header');
  var btn  = sec.querySelector('.prc-toggle-btn');

  if (!body) { return; }

  var isOpen = body.style.display !== 'none';

  if (isOpen) {
    body.style.display = 'none';
    if (btn) { btn.textContent = '\u25BA Expand'; }
    if (hdr) { hdr.setAttribute('aria-expanded', 'false'); }
  } else {
    body.style.display = '';
    if (btn) { btn.textContent = '\u25BC Collapse'; }
    if (hdr) { hdr.setAttribute('aria-expanded', 'true'); }
  }
}
[[/script]]

{/source}